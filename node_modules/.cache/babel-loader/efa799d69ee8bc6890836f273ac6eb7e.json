{"ast":null,"code":"'use strict';\n\nvar typeOf = require('kind-of');\n\nvar utils = module.exports;\n/**\r\n * Returns true if the given value is a node.\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * var node = new Node({type: 'foo'});\r\n * console.log(utils.isNode(node)); //=> true\r\n * console.log(utils.isNode({})); //=> false\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @returns {Boolean}\r\n * @api public\r\n */\n\nutils.isNode = function (node) {\n  return typeOf(node) === 'object' && node.isNode === true;\n};\n/**\r\n * Emit an empty string for the given `node`.\r\n *\r\n * ```js\r\n * // do nothing for beginning-of-string\r\n * snapdragon.compiler.set('bos', utils.noop);\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @returns {undefined}\r\n * @api public\r\n */\n\n\nutils.noop = function (node) {\n  append(this, '', node);\n};\n/**\r\n * Appdend `node.val` to `compiler.output`, exactly as it was created\r\n * by the parser.\r\n *\r\n * ```js\r\n * snapdragon.compiler.set('text', utils.identity);\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @returns {undefined}\r\n * @api public\r\n */\n\n\nutils.identity = function (node) {\n  append(this, node.val, node);\n};\n/**\r\n * Previously named `.emit`, this method appends the given `val`\r\n * to `compiler.output` for the given node. Useful when you know\r\n * what value should be appended advance, regardless of the actual\r\n * value of `node.val`.\r\n *\r\n * ```js\r\n * snapdragon.compiler\r\n *   .set('i', function(node) {\r\n *     this.mapVisit(node);\r\n *   })\r\n *   .set('i.open', utils.append('<i>'))\r\n *   .set('i.close', utils.append('</i>'))\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @returns {Function} Returns a compiler middleware function.\r\n * @api public\r\n */\n\n\nutils.append = function (val) {\n  return function (node) {\n    append(this, val, node);\n  };\n};\n/**\r\n * Used in compiler middleware, this onverts an AST node into\r\n * an empty `text` node and deletes `node.nodes` if it exists.\r\n * The advantage of this method is that, as opposed to completely\r\n * removing the node, indices will not need to be re-calculated\r\n * in sibling nodes, and nothing is appended to the output.\r\n *\r\n * ```js\r\n * utils.toNoop(node);\r\n * // convert `node.nodes` to the given value instead of deleting it\r\n * utils.toNoop(node, []);\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @param {Array} `nodes` Optionally pass a new `nodes` value, to replace the existing `node.nodes` array.\r\n * @api public\r\n */\n\n\nutils.toNoop = function (node, nodes) {\n  if (nodes) {\n    node.nodes = nodes;\n  } else {\n    delete node.nodes;\n    node.type = 'text';\n    node.val = '';\n  }\n};\n/**\r\n * Visit `node` with the given `fn`. The built-in `.visit` method in snapdragon\r\n * automatically calls registered compilers, this allows you to pass a visitor\r\n * function.\r\n *\r\n * ```js\r\n * snapdragon.compiler.set('i', function(node) {\r\n *   utils.visit(node, function(childNode) {\r\n *     // do stuff with \"childNode\"\r\n *     return childNode;\r\n *   });\r\n * });\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @param {Function} `fn`\r\n * @return {Object} returns the node after recursively visiting all child nodes.\r\n * @api public\r\n */\n\n\nutils.visit = function (node, fn) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isFunction(fn), 'expected a visitor function');\n  fn(node);\n  return node.nodes ? utils.mapVisit(node, fn) : node;\n};\n/**\r\n * Map [visit](#visit) the given `fn` over `node.nodes`. This is called by\r\n * [visit](#visit), use this method if you do not want `fn` to be called on\r\n * the first node.\r\n *\r\n * ```js\r\n * snapdragon.compiler.set('i', function(node) {\r\n *   utils.mapVisit(node, function(childNode) {\r\n *     // do stuff with \"childNode\"\r\n *     return childNode;\r\n *   });\r\n * });\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @param {Object} `options`\r\n * @param {Function} `fn`\r\n * @return {Object} returns the node\r\n * @api public\r\n */\n\n\nutils.mapVisit = function (node, fn) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isArray(node.nodes), 'expected node.nodes to be an array');\n  assert(isFunction(fn), 'expected a visitor function');\n\n  for (var i = 0; i < node.nodes.length; i++) {\n    utils.visit(node.nodes[i], fn);\n  }\n\n  return node;\n};\n/**\r\n * Unshift an `*.open` node onto `node.nodes`.\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * snapdragon.parser.set('brace', function(node) {\r\n *   var match = this.match(/^{/);\r\n *   if (match) {\r\n *     var parent = new Node({type: 'brace'});\r\n *     utils.addOpen(parent, Node);\r\n *     console.log(parent.nodes[0]):\r\n *     // { type: 'brace.open', val: '' };\r\n *\r\n *     // push the parent \"brace\" node onto the stack\r\n *     this.push(parent);\r\n *\r\n *     // return the parent node, so it's also added to the AST\r\n *     return brace;\r\n *   }\r\n * });\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\r\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\r\n * @return {Object} Returns the created opening node.\r\n * @api public\r\n */\n\n\nutils.addOpen = function (node, Node, val, filter) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isFunction(Node), 'expected Node to be a constructor function');\n\n  if (typeof val === 'function') {\n    filter = val;\n    val = '';\n  }\n\n  if (typeof filter === 'function' && !filter(node)) return;\n  var open = new Node({\n    type: node.type + '.open',\n    val: val\n  });\n  var unshift = node.unshift || node.unshiftNode;\n\n  if (typeof unshift === 'function') {\n    unshift.call(node, open);\n  } else {\n    utils.unshiftNode(node, open);\n  }\n\n  return open;\n};\n/**\r\n * Push a `*.close` node onto `node.nodes`.\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * snapdragon.parser.set('brace', function(node) {\r\n *   var match = this.match(/^}/);\r\n *   if (match) {\r\n *     var parent = this.parent();\r\n *     if (parent.type !== 'brace') {\r\n *       throw new Error('missing opening: ' + '}');\r\n *     }\r\n *\r\n *     utils.addClose(parent, Node);\r\n *     console.log(parent.nodes[parent.nodes.length - 1]):\r\n *     // { type: 'brace.close', val: '' };\r\n *\r\n *     // no need to return a node, since the parent\r\n *     // was already added to the AST\r\n *     return;\r\n *   }\r\n * });\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\r\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\r\n * @return {Object} Returns the created closing node.\r\n * @api public\r\n */\n\n\nutils.addClose = function (node, Node, val, filter) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isFunction(Node), 'expected Node to be a constructor function');\n\n  if (typeof val === 'function') {\n    filter = val;\n    val = '';\n  }\n\n  if (typeof filter === 'function' && !filter(node)) return;\n  var close = new Node({\n    type: node.type + '.close',\n    val: val\n  });\n  var push = node.push || node.pushNode;\n\n  if (typeof push === 'function') {\n    push.call(node, close);\n  } else {\n    utils.pushNode(node, close);\n  }\n\n  return close;\n};\n/**\r\n * Wraps the given `node` with `*.open` and `*.close` nodes.\r\n *\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\r\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\r\n * @return {Object} Returns the node\r\n * @api public\r\n */\n\n\nutils.wrapNodes = function (node, Node, filter) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isFunction(Node), 'expected Node to be a constructor function');\n  utils.addOpen(node, Node, filter);\n  utils.addClose(node, Node, filter);\n  return node;\n};\n/**\r\n * Push the given `node` onto `parent.nodes`, and set `parent` as `node.parent.\r\n *\r\n * ```js\r\n * var parent = new Node({type: 'foo'});\r\n * var node = new Node({type: 'bar'});\r\n * utils.pushNode(parent, node);\r\n * console.log(parent.nodes[0].type) // 'bar'\r\n * console.log(node.parent.type) // 'foo'\r\n * ```\r\n * @param {Object} `parent`\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Object} Returns the child node\r\n * @api public\r\n */\n\n\nutils.pushNode = function (parent, node) {\n  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  node.define('parent', parent);\n  parent.nodes = parent.nodes || [];\n  parent.nodes.push(node);\n  return node;\n};\n/**\r\n * Unshift `node` onto `parent.nodes`, and set `parent` as `node.parent.\r\n *\r\n * ```js\r\n * var parent = new Node({type: 'foo'});\r\n * var node = new Node({type: 'bar'});\r\n * utils.unshiftNode(parent, node);\r\n * console.log(parent.nodes[0].type) // 'bar'\r\n * console.log(node.parent.type) // 'foo'\r\n * ```\r\n * @param {Object} `parent`\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {undefined}\r\n * @api public\r\n */\n\n\nutils.unshiftNode = function (parent, node) {\n  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  node.define('parent', parent);\n  parent.nodes = parent.nodes || [];\n  parent.nodes.unshift(node);\n};\n/**\r\n * Pop the last `node` off of `parent.nodes`. The advantage of\r\n * using this method is that it checks for `node.nodes` and works\r\n * with any version of `snapdragon-node`.\r\n *\r\n * ```js\r\n * var parent = new Node({type: 'foo'});\r\n * utils.pushNode(parent, new Node({type: 'foo'}));\r\n * utils.pushNode(parent, new Node({type: 'bar'}));\r\n * utils.pushNode(parent, new Node({type: 'baz'}));\r\n * console.log(parent.nodes.length); //=> 3\r\n * utils.popNode(parent);\r\n * console.log(parent.nodes.length); //=> 2\r\n * ```\r\n * @param {Object} `parent`\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.\r\n * @api public\r\n */\n\n\nutils.popNode = function (node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n\n  if (typeof node.pop === 'function') {\n    return node.pop();\n  }\n\n  return node.nodes && node.nodes.pop();\n};\n/**\r\n * Shift the first `node` off of `parent.nodes`. The advantage of\r\n * using this method is that it checks for `node.nodes` and works\r\n * with any version of `snapdragon-node`.\r\n *\r\n * ```js\r\n * var parent = new Node({type: 'foo'});\r\n * utils.pushNode(parent, new Node({type: 'foo'}));\r\n * utils.pushNode(parent, new Node({type: 'bar'}));\r\n * utils.pushNode(parent, new Node({type: 'baz'}));\r\n * console.log(parent.nodes.length); //=> 3\r\n * utils.shiftNode(parent);\r\n * console.log(parent.nodes.length); //=> 2\r\n * ```\r\n * @param {Object} `parent`\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.\r\n * @api public\r\n */\n\n\nutils.shiftNode = function (node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n\n  if (typeof node.shift === 'function') {\n    return node.shift();\n  }\n\n  return node.nodes && node.nodes.shift();\n};\n/**\r\n * Remove the specified `node` from `parent.nodes`.\r\n *\r\n * ```js\r\n * var parent = new Node({type: 'abc'});\r\n * var foo = new Node({type: 'foo'});\r\n * utils.pushNode(parent, foo);\r\n * utils.pushNode(parent, new Node({type: 'bar'}));\r\n * utils.pushNode(parent, new Node({type: 'baz'}));\r\n * console.log(parent.nodes.length); //=> 3\r\n * utils.removeNode(parent, foo);\r\n * console.log(parent.nodes.length); //=> 2\r\n * ```\r\n * @param {Object} `parent`\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Object|undefined} Returns the removed node, if successful, or undefined if it does not exist on `parent.nodes`.\r\n * @api public\r\n */\n\n\nutils.removeNode = function (parent, node) {\n  assert(utils.isNode(parent), 'expected parent.node to be an instance of Node');\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n\n  if (!parent.nodes) {\n    return null;\n  }\n\n  if (typeof parent.remove === 'function') {\n    return parent.remove(node);\n  }\n\n  var idx = parent.nodes.indexOf(node);\n\n  if (idx !== -1) {\n    return parent.nodes.splice(idx, 1);\n  }\n};\n/**\r\n * Returns true if `node.type` matches the given `type`. Throws a\r\n * `TypeError` if `node` is not an instance of `Node`.\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * var node = new Node({type: 'foo'});\r\n * console.log(utils.isType(node, 'foo')); // false\r\n * console.log(utils.isType(node, 'bar')); // true\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @param {String} `type`\r\n * @return {Boolean}\r\n * @api public\r\n */\n\n\nutils.isType = function (node, type) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n\n  switch (typeOf(type)) {\n    case 'array':\n      var types = type.slice();\n\n      for (var i = 0; i < types.length; i++) {\n        if (utils.isType(node, types[i])) {\n          return true;\n        }\n      }\n\n      return false;\n\n    case 'string':\n      return node.type === type;\n\n    case 'regexp':\n      return type.test(node.type);\n\n    default:\n      {\n        throw new TypeError('expected \"type\" to be an array, string or regexp');\n      }\n  }\n};\n/**\r\n * Returns true if the given `node` has the given `type` in `node.nodes`.\r\n * Throws a `TypeError` if `node` is not an instance of `Node`.\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * var node = new Node({\r\n *   type: 'foo',\r\n *   nodes: [\r\n *     new Node({type: 'bar'}),\r\n *     new Node({type: 'baz'})\r\n *   ]\r\n * });\r\n * console.log(utils.hasType(node, 'xyz')); // false\r\n * console.log(utils.hasType(node, 'baz')); // true\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @param {String} `type`\r\n * @return {Boolean}\r\n * @api public\r\n */\n\n\nutils.hasType = function (node, type) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  if (!Array.isArray(node.nodes)) return false;\n\n  for (var i = 0; i < node.nodes.length; i++) {\n    if (utils.isType(node.nodes[i], type)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\r\n * Returns the first node from `node.nodes` of the given `type`\r\n *\r\n * ```js\r\n * var node = new Node({\r\n *   type: 'foo',\r\n *   nodes: [\r\n *     new Node({type: 'text', val: 'abc'}),\r\n *     new Node({type: 'text', val: 'xyz'})\r\n *   ]\r\n * });\r\n *\r\n * var textNode = utils.firstOfType(node.nodes, 'text');\r\n * console.log(textNode.val);\r\n * //=> 'abc'\r\n * ```\r\n * @param {Array} `nodes`\r\n * @param {String} `type`\r\n * @return {Object|undefined} Returns the first matching node or undefined.\r\n * @api public\r\n */\n\n\nutils.firstOfType = function (nodes, type) {\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n\n    if (utils.isType(node, type)) {\n      return node;\n    }\n  }\n};\n/**\r\n * Returns the node at the specified index, or the first node of the\r\n * given `type` from `node.nodes`.\r\n *\r\n * ```js\r\n * var node = new Node({\r\n *   type: 'foo',\r\n *   nodes: [\r\n *     new Node({type: 'text', val: 'abc'}),\r\n *     new Node({type: 'text', val: 'xyz'})\r\n *   ]\r\n * });\r\n *\r\n * var nodeOne = utils.findNode(node.nodes, 'text');\r\n * console.log(nodeOne.val);\r\n * //=> 'abc'\r\n *\r\n * var nodeTwo = utils.findNode(node.nodes, 1);\r\n * console.log(nodeTwo.val);\r\n * //=> 'xyz'\r\n * ```\r\n *\r\n * @param {Array} `nodes`\r\n * @param {String|Number} `type` Node type or index.\r\n * @return {Object} Returns a node or undefined.\r\n * @api public\r\n */\n\n\nutils.findNode = function (nodes, type) {\n  if (!Array.isArray(nodes)) {\n    return null;\n  }\n\n  if (typeof type === 'number') {\n    return nodes[type];\n  }\n\n  return utils.firstOfType(nodes, type);\n};\n/**\r\n * Returns true if the given node is an \"*.open\" node.\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * var brace = new Node({type: 'brace'});\r\n * var open = new Node({type: 'brace.open'});\r\n * var close = new Node({type: 'brace.close'});\r\n *\r\n * console.log(utils.isOpen(brace)); // false\r\n * console.log(utils.isOpen(open)); // true\r\n * console.log(utils.isOpen(close)); // false\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Boolean}\r\n * @api public\r\n */\n\n\nutils.isOpen = function (node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  return node.type.slice(-5) === '.open';\n};\n/**\r\n * Returns true if the given node is a \"*.close\" node.\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * var brace = new Node({type: 'brace'});\r\n * var open = new Node({type: 'brace.open'});\r\n * var close = new Node({type: 'brace.close'});\r\n *\r\n * console.log(utils.isClose(brace)); // false\r\n * console.log(utils.isClose(open)); // false\r\n * console.log(utils.isClose(close)); // true\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Boolean}\r\n * @api public\r\n */\n\n\nutils.isClose = function (node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  return node.type.slice(-6) === '.close';\n};\n/**\r\n * Returns true if `node.nodes` **has** an `.open` node\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * var brace = new Node({\r\n *   type: 'brace',\r\n *   nodes: []\r\n * });\r\n *\r\n * var open = new Node({type: 'brace.open'});\r\n * console.log(utils.hasOpen(brace)); // false\r\n *\r\n * brace.pushNode(open);\r\n * console.log(utils.hasOpen(brace)); // true\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Boolean}\r\n * @api public\r\n */\n\n\nutils.hasOpen = function (node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  var first = node.first || node.nodes ? node.nodes[0] : null;\n\n  if (utils.isNode(first)) {\n    return first.type === node.type + '.open';\n  }\n\n  return false;\n};\n/**\r\n * Returns true if `node.nodes` **has** a `.close` node\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * var brace = new Node({\r\n *   type: 'brace',\r\n *   nodes: []\r\n * });\r\n *\r\n * var close = new Node({type: 'brace.close'});\r\n * console.log(utils.hasClose(brace)); // false\r\n *\r\n * brace.pushNode(close);\r\n * console.log(utils.hasClose(brace)); // true\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Boolean}\r\n * @api public\r\n */\n\n\nutils.hasClose = function (node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  var last = node.last || node.nodes ? node.nodes[node.nodes.length - 1] : null;\n\n  if (utils.isNode(last)) {\n    return last.type === node.type + '.close';\n  }\n\n  return false;\n};\n/**\r\n * Returns true if `node.nodes` has both `.open` and `.close` nodes\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * var brace = new Node({\r\n *   type: 'brace',\r\n *   nodes: []\r\n * });\r\n *\r\n * var open = new Node({type: 'brace.open'});\r\n * var close = new Node({type: 'brace.close'});\r\n * console.log(utils.hasOpen(brace)); // false\r\n * console.log(utils.hasClose(brace)); // false\r\n *\r\n * brace.pushNode(open);\r\n * brace.pushNode(close);\r\n * console.log(utils.hasOpen(brace)); // true\r\n * console.log(utils.hasClose(brace)); // true\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Boolean}\r\n * @api public\r\n */\n\n\nutils.hasOpenAndClose = function (node) {\n  return utils.hasOpen(node) && utils.hasClose(node);\n};\n/**\r\n * Push the given `node` onto the `state.inside` array for the\r\n * given type. This array is used as a specialized \"stack\" for\r\n * only the given `node.type`.\r\n *\r\n * ```js\r\n * var state = { inside: {}};\r\n * var node = new Node({type: 'brace'});\r\n * utils.addType(state, node);\r\n * console.log(state.inside);\r\n * //=> { brace: [{type: 'brace'}] }\r\n * ```\r\n * @param {Object} `state` The `compiler.state` object or custom state object.\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Array} Returns the `state.inside` stack for the given type.\r\n * @api public\r\n */\n\n\nutils.addType = function (state, node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isObject(state), 'expected state to be an object');\n  var type = node.parent ? node.parent.type : node.type.replace(/\\.open$/, '');\n\n  if (!state.hasOwnProperty('inside')) {\n    state.inside = {};\n  }\n\n  if (!state.inside.hasOwnProperty(type)) {\n    state.inside[type] = [];\n  }\n\n  var arr = state.inside[type];\n  arr.push(node);\n  return arr;\n};\n/**\r\n * Remove the given `node` from the `state.inside` array for the\r\n * given type. This array is used as a specialized \"stack\" for\r\n * only the given `node.type`.\r\n *\r\n * ```js\r\n * var state = { inside: {}};\r\n * var node = new Node({type: 'brace'});\r\n * utils.addType(state, node);\r\n * console.log(state.inside);\r\n * //=> { brace: [{type: 'brace'}] }\r\n * utils.removeType(state, node);\r\n * //=> { brace: [] }\r\n * ```\r\n * @param {Object} `state` The `compiler.state` object or custom state object.\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Array} Returns the `state.inside` stack for the given type.\r\n * @api public\r\n */\n\n\nutils.removeType = function (state, node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isObject(state), 'expected state to be an object');\n  var type = node.parent ? node.parent.type : node.type.replace(/\\.close$/, '');\n\n  if (state.inside.hasOwnProperty(type)) {\n    return state.inside[type].pop();\n  }\n};\n/**\r\n * Returns true if `node.val` is an empty string, or `node.nodes` does\r\n * not contain any non-empty text nodes.\r\n *\r\n * ```js\r\n * var node = new Node({type: 'text'});\r\n * utils.isEmpty(node); //=> true\r\n * node.val = 'foo';\r\n * utils.isEmpty(node); //=> false\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @param {Function} `fn`\r\n * @return {Boolean}\r\n * @api public\r\n */\n\n\nutils.isEmpty = function (node, fn) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n\n  if (!Array.isArray(node.nodes)) {\n    if (node.type !== 'text') {\n      return true;\n    }\n\n    if (typeof fn === 'function') {\n      return fn(node, node.parent);\n    }\n\n    return !utils.trim(node.val);\n  }\n\n  for (var i = 0; i < node.nodes.length; i++) {\n    var child = node.nodes[i];\n\n    if (utils.isOpen(child) || utils.isClose(child)) {\n      continue;\n    }\n\n    if (!utils.isEmpty(child, fn)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\r\n * Returns true if the `state.inside` stack for the given type exists\r\n * and has one or more nodes on it.\r\n *\r\n * ```js\r\n * var state = { inside: {}};\r\n * var node = new Node({type: 'brace'});\r\n * console.log(utils.isInsideType(state, 'brace')); //=> false\r\n * utils.addType(state, node);\r\n * console.log(utils.isInsideType(state, 'brace')); //=> true\r\n * utils.removeType(state, node);\r\n * console.log(utils.isInsideType(state, 'brace')); //=> false\r\n * ```\r\n * @param {Object} `state`\r\n * @param {String} `type`\r\n * @return {Boolean}\r\n * @api public\r\n */\n\n\nutils.isInsideType = function (state, type) {\n  assert(isObject(state), 'expected state to be an object');\n  assert(isString(type), 'expected type to be a string');\n\n  if (!state.hasOwnProperty('inside')) {\n    return false;\n  }\n\n  if (!state.inside.hasOwnProperty(type)) {\n    return false;\n  }\n\n  return state.inside[type].length > 0;\n};\n/**\r\n * Returns true if `node` is either a child or grand-child of the given `type`,\r\n * or `state.inside[type]` is a non-empty array.\r\n *\r\n * ```js\r\n * var state = { inside: {}};\r\n * var node = new Node({type: 'brace'});\r\n * var open = new Node({type: 'brace.open'});\r\n * console.log(utils.isInside(state, open, 'brace')); //=> false\r\n * utils.pushNode(node, open);\r\n * console.log(utils.isInside(state, open, 'brace')); //=> true\r\n * ```\r\n * @param {Object} `state` Either the `compiler.state` object, if it exists, or a user-supplied state object.\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @param {String} `type` The `node.type` to check for.\r\n * @return {Boolean}\r\n * @api public\r\n */\n\n\nutils.isInside = function (state, node, type) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isObject(state), 'expected state to be an object');\n\n  if (Array.isArray(type)) {\n    for (var i = 0; i < type.length; i++) {\n      if (utils.isInside(state, node, type[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var parent = node.parent;\n\n  if (typeof type === 'string') {\n    return parent && parent.type === type || utils.isInsideType(state, type);\n  }\n\n  if (typeOf(type) === 'regexp') {\n    if (parent && parent.type && type.test(parent.type)) {\n      return true;\n    }\n\n    var keys = Object.keys(state.inside);\n    var len = keys.length;\n    var idx = -1;\n\n    while (++idx < len) {\n      var key = keys[idx];\n      var val = state.inside[key];\n\n      if (Array.isArray(val) && val.length !== 0 && type.test(key)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n/**\r\n * Get the last `n` element from the given `array`. Used for getting\r\n * a node from `node.nodes.`\r\n *\r\n * @param {Array} `array`\r\n * @param {Number} `n`\r\n * @return {undefined}\r\n * @api public\r\n */\n\n\nutils.last = function (arr, n) {\n  return arr[arr.length - (n || 1)];\n};\n/**\r\n * Cast the given `val` to an array.\r\n *\r\n * ```js\r\n * console.log(utils.arrayify(''));\r\n * //=> []\r\n * console.log(utils.arrayify('foo'));\r\n * //=> ['foo']\r\n * console.log(utils.arrayify(['foo']));\r\n * //=> ['foo']\r\n * ```\r\n * @param {any} `val`\r\n * @return {Array}\r\n * @api public\r\n */\n\n\nutils.arrayify = function (val) {\n  if (typeof val === 'string' && val !== '') {\n    return [val];\n  }\n\n  if (!Array.isArray(val)) {\n    return [];\n  }\n\n  return val;\n};\n/**\r\n * Convert the given `val` to a string by joining with `,`. Useful\r\n * for creating a cheerio/CSS/DOM-style selector from a list of strings.\r\n *\r\n * @param {any} `val`\r\n * @return {Array}\r\n * @api public\r\n */\n\n\nutils.stringify = function (val) {\n  return utils.arrayify(val).join(',');\n};\n/**\r\n * Ensure that the given value is a string and call `.trim()` on it,\r\n * or return an empty string.\r\n *\r\n * @param {String} `str`\r\n * @return {String}\r\n * @api public\r\n */\n\n\nutils.trim = function (str) {\n  return typeof str === 'string' ? str.trim() : '';\n};\n/**\r\n * Return true if val is an object\r\n */\n\n\nfunction isObject(val) {\n  return typeOf(val) === 'object';\n}\n/**\r\n * Return true if val is a string\r\n */\n\n\nfunction isString(val) {\n  return typeof val === 'string';\n}\n/**\r\n * Return true if val is a function\r\n */\n\n\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\n/**\r\n * Return true if val is an array\r\n */\n\n\nfunction isArray(val) {\n  return Array.isArray(val);\n}\n/**\r\n * Shim to ensure the `.append` methods work with any version of snapdragon\r\n */\n\n\nfunction append(compiler, val, node) {\n  if (typeof compiler.append !== 'function') {\n    return compiler.emit(val, node);\n  }\n\n  return compiler.append(val, node);\n}\n/**\r\n * Simplified assertion. Throws an error is `val` is falsey.\r\n */\n\n\nfunction assert(val, message) {\n  if (!val) throw new Error(message);\n}","map":{"version":3,"sources":["C:/Users/lykam/Desktop/Senior Project/team05_react_app/node_modules/snapdragon-util/index.js"],"names":["typeOf","require","utils","module","exports","isNode","node","noop","append","identity","val","toNoop","nodes","type","visit","fn","assert","isFunction","mapVisit","isArray","i","length","addOpen","Node","filter","open","unshift","unshiftNode","call","addClose","close","push","pushNode","wrapNodes","parent","define","popNode","pop","shiftNode","shift","removeNode","remove","idx","indexOf","splice","isType","types","slice","test","TypeError","hasType","Array","firstOfType","findNode","isOpen","isClose","hasOpen","first","hasClose","last","hasOpenAndClose","addType","state","isObject","replace","hasOwnProperty","inside","arr","removeType","isEmpty","trim","child","isInsideType","isString","isInside","keys","Object","len","key","n","arrayify","stringify","join","str","compiler","emit","message","Error"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar typeOf = require('kind-of');\r\nvar utils = module.exports;\r\n\r\n/**\r\n * Returns true if the given value is a node.\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * var node = new Node({type: 'foo'});\r\n * console.log(utils.isNode(node)); //=> true\r\n * console.log(utils.isNode({})); //=> false\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @returns {Boolean}\r\n * @api public\r\n */\r\n\r\nutils.isNode = function(node) {\r\n  return typeOf(node) === 'object' && node.isNode === true;\r\n};\r\n\r\n/**\r\n * Emit an empty string for the given `node`.\r\n *\r\n * ```js\r\n * // do nothing for beginning-of-string\r\n * snapdragon.compiler.set('bos', utils.noop);\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @returns {undefined}\r\n * @api public\r\n */\r\n\r\nutils.noop = function(node) {\r\n  append(this, '', node);\r\n};\r\n\r\n/**\r\n * Appdend `node.val` to `compiler.output`, exactly as it was created\r\n * by the parser.\r\n *\r\n * ```js\r\n * snapdragon.compiler.set('text', utils.identity);\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @returns {undefined}\r\n * @api public\r\n */\r\n\r\nutils.identity = function(node) {\r\n  append(this, node.val, node);\r\n};\r\n\r\n/**\r\n * Previously named `.emit`, this method appends the given `val`\r\n * to `compiler.output` for the given node. Useful when you know\r\n * what value should be appended advance, regardless of the actual\r\n * value of `node.val`.\r\n *\r\n * ```js\r\n * snapdragon.compiler\r\n *   .set('i', function(node) {\r\n *     this.mapVisit(node);\r\n *   })\r\n *   .set('i.open', utils.append('<i>'))\r\n *   .set('i.close', utils.append('</i>'))\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @returns {Function} Returns a compiler middleware function.\r\n * @api public\r\n */\r\n\r\nutils.append = function(val) {\r\n  return function(node) {\r\n    append(this, val, node);\r\n  };\r\n};\r\n\r\n/**\r\n * Used in compiler middleware, this onverts an AST node into\r\n * an empty `text` node and deletes `node.nodes` if it exists.\r\n * The advantage of this method is that, as opposed to completely\r\n * removing the node, indices will not need to be re-calculated\r\n * in sibling nodes, and nothing is appended to the output.\r\n *\r\n * ```js\r\n * utils.toNoop(node);\r\n * // convert `node.nodes` to the given value instead of deleting it\r\n * utils.toNoop(node, []);\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @param {Array} `nodes` Optionally pass a new `nodes` value, to replace the existing `node.nodes` array.\r\n * @api public\r\n */\r\n\r\nutils.toNoop = function(node, nodes) {\r\n  if (nodes) {\r\n    node.nodes = nodes;\r\n  } else {\r\n    delete node.nodes;\r\n    node.type = 'text';\r\n    node.val = '';\r\n  }\r\n};\r\n\r\n/**\r\n * Visit `node` with the given `fn`. The built-in `.visit` method in snapdragon\r\n * automatically calls registered compilers, this allows you to pass a visitor\r\n * function.\r\n *\r\n * ```js\r\n * snapdragon.compiler.set('i', function(node) {\r\n *   utils.visit(node, function(childNode) {\r\n *     // do stuff with \"childNode\"\r\n *     return childNode;\r\n *   });\r\n * });\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @param {Function} `fn`\r\n * @return {Object} returns the node after recursively visiting all child nodes.\r\n * @api public\r\n */\r\n\r\nutils.visit = function(node, fn) {\r\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\r\n  assert(isFunction(fn), 'expected a visitor function');\r\n  fn(node);\r\n  return node.nodes ? utils.mapVisit(node, fn) : node;\r\n};\r\n\r\n/**\r\n * Map [visit](#visit) the given `fn` over `node.nodes`. This is called by\r\n * [visit](#visit), use this method if you do not want `fn` to be called on\r\n * the first node.\r\n *\r\n * ```js\r\n * snapdragon.compiler.set('i', function(node) {\r\n *   utils.mapVisit(node, function(childNode) {\r\n *     // do stuff with \"childNode\"\r\n *     return childNode;\r\n *   });\r\n * });\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @param {Object} `options`\r\n * @param {Function} `fn`\r\n * @return {Object} returns the node\r\n * @api public\r\n */\r\n\r\nutils.mapVisit = function(node, fn) {\r\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\r\n  assert(isArray(node.nodes), 'expected node.nodes to be an array');\r\n  assert(isFunction(fn), 'expected a visitor function');\r\n\r\n  for (var i = 0; i < node.nodes.length; i++) {\r\n    utils.visit(node.nodes[i], fn);\r\n  }\r\n  return node;\r\n};\r\n\r\n/**\r\n * Unshift an `*.open` node onto `node.nodes`.\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * snapdragon.parser.set('brace', function(node) {\r\n *   var match = this.match(/^{/);\r\n *   if (match) {\r\n *     var parent = new Node({type: 'brace'});\r\n *     utils.addOpen(parent, Node);\r\n *     console.log(parent.nodes[0]):\r\n *     // { type: 'brace.open', val: '' };\r\n *\r\n *     // push the parent \"brace\" node onto the stack\r\n *     this.push(parent);\r\n *\r\n *     // return the parent node, so it's also added to the AST\r\n *     return brace;\r\n *   }\r\n * });\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\r\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\r\n * @return {Object} Returns the created opening node.\r\n * @api public\r\n */\r\n\r\nutils.addOpen = function(node, Node, val, filter) {\r\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\r\n  assert(isFunction(Node), 'expected Node to be a constructor function');\r\n\r\n  if (typeof val === 'function') {\r\n    filter = val;\r\n    val = '';\r\n  }\r\n\r\n  if (typeof filter === 'function' && !filter(node)) return;\r\n  var open = new Node({ type: node.type + '.open', val: val});\r\n  var unshift = node.unshift || node.unshiftNode;\r\n  if (typeof unshift === 'function') {\r\n    unshift.call(node, open);\r\n  } else {\r\n    utils.unshiftNode(node, open);\r\n  }\r\n  return open;\r\n};\r\n\r\n/**\r\n * Push a `*.close` node onto `node.nodes`.\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * snapdragon.parser.set('brace', function(node) {\r\n *   var match = this.match(/^}/);\r\n *   if (match) {\r\n *     var parent = this.parent();\r\n *     if (parent.type !== 'brace') {\r\n *       throw new Error('missing opening: ' + '}');\r\n *     }\r\n *\r\n *     utils.addClose(parent, Node);\r\n *     console.log(parent.nodes[parent.nodes.length - 1]):\r\n *     // { type: 'brace.close', val: '' };\r\n *\r\n *     // no need to return a node, since the parent\r\n *     // was already added to the AST\r\n *     return;\r\n *   }\r\n * });\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\r\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\r\n * @return {Object} Returns the created closing node.\r\n * @api public\r\n */\r\n\r\nutils.addClose = function(node, Node, val, filter) {\r\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\r\n  assert(isFunction(Node), 'expected Node to be a constructor function');\r\n\r\n  if (typeof val === 'function') {\r\n    filter = val;\r\n    val = '';\r\n  }\r\n\r\n  if (typeof filter === 'function' && !filter(node)) return;\r\n  var close = new Node({ type: node.type + '.close', val: val});\r\n  var push = node.push || node.pushNode;\r\n  if (typeof push === 'function') {\r\n    push.call(node, close);\r\n  } else {\r\n    utils.pushNode(node, close);\r\n  }\r\n  return close;\r\n};\r\n\r\n/**\r\n * Wraps the given `node` with `*.open` and `*.close` nodes.\r\n *\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\r\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\r\n * @return {Object} Returns the node\r\n * @api public\r\n */\r\n\r\nutils.wrapNodes = function(node, Node, filter) {\r\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\r\n  assert(isFunction(Node), 'expected Node to be a constructor function');\r\n\r\n  utils.addOpen(node, Node, filter);\r\n  utils.addClose(node, Node, filter);\r\n  return node;\r\n};\r\n\r\n/**\r\n * Push the given `node` onto `parent.nodes`, and set `parent` as `node.parent.\r\n *\r\n * ```js\r\n * var parent = new Node({type: 'foo'});\r\n * var node = new Node({type: 'bar'});\r\n * utils.pushNode(parent, node);\r\n * console.log(parent.nodes[0].type) // 'bar'\r\n * console.log(node.parent.type) // 'foo'\r\n * ```\r\n * @param {Object} `parent`\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Object} Returns the child node\r\n * @api public\r\n */\r\n\r\nutils.pushNode = function(parent, node) {\r\n  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');\r\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\r\n\r\n  node.define('parent', parent);\r\n  parent.nodes = parent.nodes || [];\r\n  parent.nodes.push(node);\r\n  return node;\r\n};\r\n\r\n/**\r\n * Unshift `node` onto `parent.nodes`, and set `parent` as `node.parent.\r\n *\r\n * ```js\r\n * var parent = new Node({type: 'foo'});\r\n * var node = new Node({type: 'bar'});\r\n * utils.unshiftNode(parent, node);\r\n * console.log(parent.nodes[0].type) // 'bar'\r\n * console.log(node.parent.type) // 'foo'\r\n * ```\r\n * @param {Object} `parent`\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {undefined}\r\n * @api public\r\n */\r\n\r\nutils.unshiftNode = function(parent, node) {\r\n  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');\r\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\r\n\r\n  node.define('parent', parent);\r\n  parent.nodes = parent.nodes || [];\r\n  parent.nodes.unshift(node);\r\n};\r\n\r\n/**\r\n * Pop the last `node` off of `parent.nodes`. The advantage of\r\n * using this method is that it checks for `node.nodes` and works\r\n * with any version of `snapdragon-node`.\r\n *\r\n * ```js\r\n * var parent = new Node({type: 'foo'});\r\n * utils.pushNode(parent, new Node({type: 'foo'}));\r\n * utils.pushNode(parent, new Node({type: 'bar'}));\r\n * utils.pushNode(parent, new Node({type: 'baz'}));\r\n * console.log(parent.nodes.length); //=> 3\r\n * utils.popNode(parent);\r\n * console.log(parent.nodes.length); //=> 2\r\n * ```\r\n * @param {Object} `parent`\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.\r\n * @api public\r\n */\r\n\r\nutils.popNode = function(node) {\r\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\r\n  if (typeof node.pop === 'function') {\r\n    return node.pop();\r\n  }\r\n  return node.nodes && node.nodes.pop();\r\n};\r\n\r\n/**\r\n * Shift the first `node` off of `parent.nodes`. The advantage of\r\n * using this method is that it checks for `node.nodes` and works\r\n * with any version of `snapdragon-node`.\r\n *\r\n * ```js\r\n * var parent = new Node({type: 'foo'});\r\n * utils.pushNode(parent, new Node({type: 'foo'}));\r\n * utils.pushNode(parent, new Node({type: 'bar'}));\r\n * utils.pushNode(parent, new Node({type: 'baz'}));\r\n * console.log(parent.nodes.length); //=> 3\r\n * utils.shiftNode(parent);\r\n * console.log(parent.nodes.length); //=> 2\r\n * ```\r\n * @param {Object} `parent`\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.\r\n * @api public\r\n */\r\n\r\nutils.shiftNode = function(node) {\r\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\r\n  if (typeof node.shift === 'function') {\r\n    return node.shift();\r\n  }\r\n  return node.nodes && node.nodes.shift();\r\n};\r\n\r\n/**\r\n * Remove the specified `node` from `parent.nodes`.\r\n *\r\n * ```js\r\n * var parent = new Node({type: 'abc'});\r\n * var foo = new Node({type: 'foo'});\r\n * utils.pushNode(parent, foo);\r\n * utils.pushNode(parent, new Node({type: 'bar'}));\r\n * utils.pushNode(parent, new Node({type: 'baz'}));\r\n * console.log(parent.nodes.length); //=> 3\r\n * utils.removeNode(parent, foo);\r\n * console.log(parent.nodes.length); //=> 2\r\n * ```\r\n * @param {Object} `parent`\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Object|undefined} Returns the removed node, if successful, or undefined if it does not exist on `parent.nodes`.\r\n * @api public\r\n */\r\n\r\nutils.removeNode = function(parent, node) {\r\n  assert(utils.isNode(parent), 'expected parent.node to be an instance of Node');\r\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\r\n\r\n  if (!parent.nodes) {\r\n    return null;\r\n  }\r\n\r\n  if (typeof parent.remove === 'function') {\r\n    return parent.remove(node);\r\n  }\r\n\r\n  var idx = parent.nodes.indexOf(node);\r\n  if (idx !== -1) {\r\n    return parent.nodes.splice(idx, 1);\r\n  }\r\n};\r\n\r\n/**\r\n * Returns true if `node.type` matches the given `type`. Throws a\r\n * `TypeError` if `node` is not an instance of `Node`.\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * var node = new Node({type: 'foo'});\r\n * console.log(utils.isType(node, 'foo')); // false\r\n * console.log(utils.isType(node, 'bar')); // true\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @param {String} `type`\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nutils.isType = function(node, type) {\r\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\r\n  switch (typeOf(type)) {\r\n    case 'array':\r\n      var types = type.slice();\r\n      for (var i = 0; i < types.length; i++) {\r\n        if (utils.isType(node, types[i])) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    case 'string':\r\n      return node.type === type;\r\n    case 'regexp':\r\n      return type.test(node.type);\r\n    default: {\r\n      throw new TypeError('expected \"type\" to be an array, string or regexp');\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Returns true if the given `node` has the given `type` in `node.nodes`.\r\n * Throws a `TypeError` if `node` is not an instance of `Node`.\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * var node = new Node({\r\n *   type: 'foo',\r\n *   nodes: [\r\n *     new Node({type: 'bar'}),\r\n *     new Node({type: 'baz'})\r\n *   ]\r\n * });\r\n * console.log(utils.hasType(node, 'xyz')); // false\r\n * console.log(utils.hasType(node, 'baz')); // true\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @param {String} `type`\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nutils.hasType = function(node, type) {\r\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\r\n  if (!Array.isArray(node.nodes)) return false;\r\n  for (var i = 0; i < node.nodes.length; i++) {\r\n    if (utils.isType(node.nodes[i], type)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Returns the first node from `node.nodes` of the given `type`\r\n *\r\n * ```js\r\n * var node = new Node({\r\n *   type: 'foo',\r\n *   nodes: [\r\n *     new Node({type: 'text', val: 'abc'}),\r\n *     new Node({type: 'text', val: 'xyz'})\r\n *   ]\r\n * });\r\n *\r\n * var textNode = utils.firstOfType(node.nodes, 'text');\r\n * console.log(textNode.val);\r\n * //=> 'abc'\r\n * ```\r\n * @param {Array} `nodes`\r\n * @param {String} `type`\r\n * @return {Object|undefined} Returns the first matching node or undefined.\r\n * @api public\r\n */\r\n\r\nutils.firstOfType = function(nodes, type) {\r\n  for (var i = 0; i < nodes.length; i++) {\r\n    var node = nodes[i];\r\n    if (utils.isType(node, type)) {\r\n      return node;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Returns the node at the specified index, or the first node of the\r\n * given `type` from `node.nodes`.\r\n *\r\n * ```js\r\n * var node = new Node({\r\n *   type: 'foo',\r\n *   nodes: [\r\n *     new Node({type: 'text', val: 'abc'}),\r\n *     new Node({type: 'text', val: 'xyz'})\r\n *   ]\r\n * });\r\n *\r\n * var nodeOne = utils.findNode(node.nodes, 'text');\r\n * console.log(nodeOne.val);\r\n * //=> 'abc'\r\n *\r\n * var nodeTwo = utils.findNode(node.nodes, 1);\r\n * console.log(nodeTwo.val);\r\n * //=> 'xyz'\r\n * ```\r\n *\r\n * @param {Array} `nodes`\r\n * @param {String|Number} `type` Node type or index.\r\n * @return {Object} Returns a node or undefined.\r\n * @api public\r\n */\r\n\r\nutils.findNode = function(nodes, type) {\r\n  if (!Array.isArray(nodes)) {\r\n    return null;\r\n  }\r\n  if (typeof type === 'number') {\r\n    return nodes[type];\r\n  }\r\n  return utils.firstOfType(nodes, type);\r\n};\r\n\r\n/**\r\n * Returns true if the given node is an \"*.open\" node.\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * var brace = new Node({type: 'brace'});\r\n * var open = new Node({type: 'brace.open'});\r\n * var close = new Node({type: 'brace.close'});\r\n *\r\n * console.log(utils.isOpen(brace)); // false\r\n * console.log(utils.isOpen(open)); // true\r\n * console.log(utils.isOpen(close)); // false\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nutils.isOpen = function(node) {\r\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\r\n  return node.type.slice(-5) === '.open';\r\n};\r\n\r\n/**\r\n * Returns true if the given node is a \"*.close\" node.\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * var brace = new Node({type: 'brace'});\r\n * var open = new Node({type: 'brace.open'});\r\n * var close = new Node({type: 'brace.close'});\r\n *\r\n * console.log(utils.isClose(brace)); // false\r\n * console.log(utils.isClose(open)); // false\r\n * console.log(utils.isClose(close)); // true\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nutils.isClose = function(node) {\r\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\r\n  return node.type.slice(-6) === '.close';\r\n};\r\n\r\n/**\r\n * Returns true if `node.nodes` **has** an `.open` node\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * var brace = new Node({\r\n *   type: 'brace',\r\n *   nodes: []\r\n * });\r\n *\r\n * var open = new Node({type: 'brace.open'});\r\n * console.log(utils.hasOpen(brace)); // false\r\n *\r\n * brace.pushNode(open);\r\n * console.log(utils.hasOpen(brace)); // true\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nutils.hasOpen = function(node) {\r\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\r\n  var first = node.first || node.nodes ? node.nodes[0] : null;\r\n  if (utils.isNode(first)) {\r\n    return first.type === node.type + '.open';\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Returns true if `node.nodes` **has** a `.close` node\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * var brace = new Node({\r\n *   type: 'brace',\r\n *   nodes: []\r\n * });\r\n *\r\n * var close = new Node({type: 'brace.close'});\r\n * console.log(utils.hasClose(brace)); // false\r\n *\r\n * brace.pushNode(close);\r\n * console.log(utils.hasClose(brace)); // true\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nutils.hasClose = function(node) {\r\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\r\n  var last = node.last || node.nodes ? node.nodes[node.nodes.length - 1] : null;\r\n  if (utils.isNode(last)) {\r\n    return last.type === node.type + '.close';\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Returns true if `node.nodes` has both `.open` and `.close` nodes\r\n *\r\n * ```js\r\n * var Node = require('snapdragon-node');\r\n * var brace = new Node({\r\n *   type: 'brace',\r\n *   nodes: []\r\n * });\r\n *\r\n * var open = new Node({type: 'brace.open'});\r\n * var close = new Node({type: 'brace.close'});\r\n * console.log(utils.hasOpen(brace)); // false\r\n * console.log(utils.hasClose(brace)); // false\r\n *\r\n * brace.pushNode(open);\r\n * brace.pushNode(close);\r\n * console.log(utils.hasOpen(brace)); // true\r\n * console.log(utils.hasClose(brace)); // true\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nutils.hasOpenAndClose = function(node) {\r\n  return utils.hasOpen(node) && utils.hasClose(node);\r\n};\r\n\r\n/**\r\n * Push the given `node` onto the `state.inside` array for the\r\n * given type. This array is used as a specialized \"stack\" for\r\n * only the given `node.type`.\r\n *\r\n * ```js\r\n * var state = { inside: {}};\r\n * var node = new Node({type: 'brace'});\r\n * utils.addType(state, node);\r\n * console.log(state.inside);\r\n * //=> { brace: [{type: 'brace'}] }\r\n * ```\r\n * @param {Object} `state` The `compiler.state` object or custom state object.\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Array} Returns the `state.inside` stack for the given type.\r\n * @api public\r\n */\r\n\r\nutils.addType = function(state, node) {\r\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\r\n  assert(isObject(state), 'expected state to be an object');\r\n\r\n  var type = node.parent\r\n    ? node.parent.type\r\n    : node.type.replace(/\\.open$/, '');\r\n\r\n  if (!state.hasOwnProperty('inside')) {\r\n    state.inside = {};\r\n  }\r\n  if (!state.inside.hasOwnProperty(type)) {\r\n    state.inside[type] = [];\r\n  }\r\n\r\n  var arr = state.inside[type];\r\n  arr.push(node);\r\n  return arr;\r\n};\r\n\r\n/**\r\n * Remove the given `node` from the `state.inside` array for the\r\n * given type. This array is used as a specialized \"stack\" for\r\n * only the given `node.type`.\r\n *\r\n * ```js\r\n * var state = { inside: {}};\r\n * var node = new Node({type: 'brace'});\r\n * utils.addType(state, node);\r\n * console.log(state.inside);\r\n * //=> { brace: [{type: 'brace'}] }\r\n * utils.removeType(state, node);\r\n * //=> { brace: [] }\r\n * ```\r\n * @param {Object} `state` The `compiler.state` object or custom state object.\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @return {Array} Returns the `state.inside` stack for the given type.\r\n * @api public\r\n */\r\n\r\nutils.removeType = function(state, node) {\r\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\r\n  assert(isObject(state), 'expected state to be an object');\r\n\r\n  var type = node.parent\r\n    ? node.parent.type\r\n    : node.type.replace(/\\.close$/, '');\r\n\r\n  if (state.inside.hasOwnProperty(type)) {\r\n    return state.inside[type].pop();\r\n  }\r\n};\r\n\r\n/**\r\n * Returns true if `node.val` is an empty string, or `node.nodes` does\r\n * not contain any non-empty text nodes.\r\n *\r\n * ```js\r\n * var node = new Node({type: 'text'});\r\n * utils.isEmpty(node); //=> true\r\n * node.val = 'foo';\r\n * utils.isEmpty(node); //=> false\r\n * ```\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @param {Function} `fn`\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nutils.isEmpty = function(node, fn) {\r\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\r\n\r\n  if (!Array.isArray(node.nodes)) {\r\n    if (node.type !== 'text') {\r\n      return true;\r\n    }\r\n    if (typeof fn === 'function') {\r\n      return fn(node, node.parent);\r\n    }\r\n    return !utils.trim(node.val);\r\n  }\r\n\r\n  for (var i = 0; i < node.nodes.length; i++) {\r\n    var child = node.nodes[i];\r\n    if (utils.isOpen(child) || utils.isClose(child)) {\r\n      continue;\r\n    }\r\n    if (!utils.isEmpty(child, fn)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n/**\r\n * Returns true if the `state.inside` stack for the given type exists\r\n * and has one or more nodes on it.\r\n *\r\n * ```js\r\n * var state = { inside: {}};\r\n * var node = new Node({type: 'brace'});\r\n * console.log(utils.isInsideType(state, 'brace')); //=> false\r\n * utils.addType(state, node);\r\n * console.log(utils.isInsideType(state, 'brace')); //=> true\r\n * utils.removeType(state, node);\r\n * console.log(utils.isInsideType(state, 'brace')); //=> false\r\n * ```\r\n * @param {Object} `state`\r\n * @param {String} `type`\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nutils.isInsideType = function(state, type) {\r\n  assert(isObject(state), 'expected state to be an object');\r\n  assert(isString(type), 'expected type to be a string');\r\n\r\n  if (!state.hasOwnProperty('inside')) {\r\n    return false;\r\n  }\r\n\r\n  if (!state.inside.hasOwnProperty(type)) {\r\n    return false;\r\n  }\r\n\r\n  return state.inside[type].length > 0;\r\n};\r\n\r\n/**\r\n * Returns true if `node` is either a child or grand-child of the given `type`,\r\n * or `state.inside[type]` is a non-empty array.\r\n *\r\n * ```js\r\n * var state = { inside: {}};\r\n * var node = new Node({type: 'brace'});\r\n * var open = new Node({type: 'brace.open'});\r\n * console.log(utils.isInside(state, open, 'brace')); //=> false\r\n * utils.pushNode(node, open);\r\n * console.log(utils.isInside(state, open, 'brace')); //=> true\r\n * ```\r\n * @param {Object} `state` Either the `compiler.state` object, if it exists, or a user-supplied state object.\r\n * @param {Object} `node` Instance of [snapdragon-node][]\r\n * @param {String} `type` The `node.type` to check for.\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nutils.isInside = function(state, node, type) {\r\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\r\n  assert(isObject(state), 'expected state to be an object');\r\n\r\n  if (Array.isArray(type)) {\r\n    for (var i = 0; i < type.length; i++) {\r\n      if (utils.isInside(state, node, type[i])) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  var parent = node.parent;\r\n  if (typeof type === 'string') {\r\n    return (parent && parent.type === type) || utils.isInsideType(state, type);\r\n  }\r\n\r\n  if (typeOf(type) === 'regexp') {\r\n    if (parent && parent.type && type.test(parent.type)) {\r\n      return true;\r\n    }\r\n\r\n    var keys = Object.keys(state.inside);\r\n    var len = keys.length;\r\n    var idx = -1;\r\n    while (++idx < len) {\r\n      var key = keys[idx];\r\n      var val = state.inside[key];\r\n\r\n      if (Array.isArray(val) && val.length !== 0 && type.test(key)) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Get the last `n` element from the given `array`. Used for getting\r\n * a node from `node.nodes.`\r\n *\r\n * @param {Array} `array`\r\n * @param {Number} `n`\r\n * @return {undefined}\r\n * @api public\r\n */\r\n\r\nutils.last = function(arr, n) {\r\n  return arr[arr.length - (n || 1)];\r\n};\r\n\r\n/**\r\n * Cast the given `val` to an array.\r\n *\r\n * ```js\r\n * console.log(utils.arrayify(''));\r\n * //=> []\r\n * console.log(utils.arrayify('foo'));\r\n * //=> ['foo']\r\n * console.log(utils.arrayify(['foo']));\r\n * //=> ['foo']\r\n * ```\r\n * @param {any} `val`\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nutils.arrayify = function(val) {\r\n  if (typeof val === 'string' && val !== '') {\r\n    return [val];\r\n  }\r\n  if (!Array.isArray(val)) {\r\n    return [];\r\n  }\r\n  return val;\r\n};\r\n\r\n/**\r\n * Convert the given `val` to a string by joining with `,`. Useful\r\n * for creating a cheerio/CSS/DOM-style selector from a list of strings.\r\n *\r\n * @param {any} `val`\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nutils.stringify = function(val) {\r\n  return utils.arrayify(val).join(',');\r\n};\r\n\r\n/**\r\n * Ensure that the given value is a string and call `.trim()` on it,\r\n * or return an empty string.\r\n *\r\n * @param {String} `str`\r\n * @return {String}\r\n * @api public\r\n */\r\n\r\nutils.trim = function(str) {\r\n  return typeof str === 'string' ? str.trim() : '';\r\n};\r\n\r\n/**\r\n * Return true if val is an object\r\n */\r\n\r\nfunction isObject(val) {\r\n  return typeOf(val) === 'object';\r\n}\r\n\r\n/**\r\n * Return true if val is a string\r\n */\r\n\r\nfunction isString(val) {\r\n  return typeof val === 'string';\r\n}\r\n\r\n/**\r\n * Return true if val is a function\r\n */\r\n\r\nfunction isFunction(val) {\r\n  return typeof val === 'function';\r\n}\r\n\r\n/**\r\n * Return true if val is an array\r\n */\r\n\r\nfunction isArray(val) {\r\n  return Array.isArray(val);\r\n}\r\n\r\n/**\r\n * Shim to ensure the `.append` methods work with any version of snapdragon\r\n */\r\n\r\nfunction append(compiler, val, node) {\r\n  if (typeof compiler.append !== 'function') {\r\n    return compiler.emit(val, node);\r\n  }\r\n  return compiler.append(val, node);\r\n}\r\n\r\n/**\r\n * Simplified assertion. Throws an error is `val` is falsey.\r\n */\r\n\r\nfunction assert(val, message) {\r\n  if (!val) throw new Error(message);\r\n}\r\n"]},"metadata":{},"sourceType":"script"}