{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nObject.defineProperty(exports, 'Frame', {\n  enumerable: true,\n  get: function get() {\n    return _types.Frame;\n  }\n});\nexports.separateMessageFromStack = exports.formatResultsErrors = exports.formatStackTrace = exports.getTopFrame = exports.getStackTraceLines = exports.formatExecError = void 0;\n\nvar _fs = _interopRequireDefault(require('fs'));\n\nvar _path = _interopRequireDefault(require('path'));\n\nvar _chalk = _interopRequireDefault(require('chalk'));\n\nvar _micromatch = _interopRequireDefault(require('micromatch'));\n\nvar _slash = _interopRequireDefault(require('slash'));\n\nvar _codeFrame = require('@babel/code-frame');\n\nvar _stackUtils = _interopRequireDefault(require('stack-utils'));\n\nvar _types = require('./types');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\n\nvar jestReadFile = global[Symbol.for('jest-native-read-file')] || _fs.default.readFileSync;\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol; // stack utils tries to create pretty stack by making paths relative.\n\nconst stackUtils = new _stackUtils.default({\n  cwd: 'something which does not exist'\n});\nlet nodeInternals = [];\n\ntry {\n  nodeInternals = _stackUtils.default.nodeInternals();\n} catch (e) {// `StackUtils.nodeInternals()` fails in browsers. We don't need to remove\n  // node internals in the browser though, so no issue.\n}\n\nconst PATH_NODE_MODULES = `${_path.default.sep}node_modules${_path.default.sep}`;\nconst PATH_JEST_PACKAGES = `${_path.default.sep}jest${_path.default.sep}packages${_path.default.sep}`; // filter for noisy stack trace lines\n\nconst JASMINE_IGNORE = /^\\s+at(?:(?:.jasmine\\-)|\\s+jasmine\\.buildExpectationResult)/;\nconst JEST_INTERNALS_IGNORE = /^\\s+at.*?jest(-.*?)?(\\/|\\\\)(build|node_modules|packages)(\\/|\\\\)/;\nconst ANONYMOUS_FN_IGNORE = /^\\s+at <anonymous>.*$/;\nconst ANONYMOUS_PROMISE_IGNORE = /^\\s+at (new )?Promise \\(<anonymous>\\).*$/;\nconst ANONYMOUS_GENERATOR_IGNORE = /^\\s+at Generator.next \\(<anonymous>\\).*$/;\nconst NATIVE_NEXT_IGNORE = /^\\s+at next \\(native\\).*$/;\nconst TITLE_INDENT = '  ';\nconst MESSAGE_INDENT = '    ';\nconst STACK_INDENT = '      ';\nconst ANCESTRY_SEPARATOR = ' \\u203A ';\n\nconst TITLE_BULLET = _chalk.default.bold('\\u25cf ');\n\nconst STACK_TRACE_COLOR = _chalk.default.dim;\nconst STACK_PATH_REGEXP = /\\s*at.*\\(?(\\:\\d*\\:\\d*|native)\\)?/;\nconst EXEC_ERROR_MESSAGE = 'Test suite failed to run';\nconst NOT_EMPTY_LINE_REGEXP = /^(?!$)/gm;\n\nconst indentAllLines = (lines, indent) => lines.replace(NOT_EMPTY_LINE_REGEXP, indent);\n\nconst trim = string => (string || '').trim(); // Some errors contain not only line numbers in stack traces\n// e.g. SyntaxErrors can contain snippets of code, and we don't\n// want to trim those, because they may have pointers to the column/character\n// which will get misaligned.\n\n\nconst trimPaths = string => string.match(STACK_PATH_REGEXP) ? trim(string) : string;\n\nconst getRenderedCallsite = (fileContent, line, column) => {\n  let renderedCallsite = (0, _codeFrame.codeFrameColumns)(fileContent, {\n    start: {\n      column,\n      line\n    }\n  }, {\n    highlightCode: true\n  });\n  renderedCallsite = indentAllLines(renderedCallsite, MESSAGE_INDENT);\n  renderedCallsite = `\\n${renderedCallsite}\\n`;\n  return renderedCallsite;\n};\n\nconst blankStringRegexp = /^\\s*$/; // ExecError is an error thrown outside of the test suite (not inside an `it` or\n// `before/after each` hooks). If it's thrown, none of the tests in the file\n// are executed.\n\nconst formatExecError = (error, config, options, testPath, reuseMessage) => {\n  if (!error || typeof error === 'number') {\n    error = new Error(`Expected an Error, but \"${String(error)}\" was thrown`);\n    error.stack = '';\n  }\n\n  let message, stack;\n\n  if (typeof error === 'string' || !error) {\n    error || (error = 'EMPTY ERROR');\n    message = '';\n    stack = error;\n  } else {\n    message = error.message;\n    stack = error.stack;\n  }\n\n  const separated = separateMessageFromStack(stack || '');\n  stack = separated.stack;\n\n  if (separated.message.includes(trim(message))) {\n    // Often stack trace already contains the duplicate of the message\n    message = separated.message;\n  }\n\n  message = indentAllLines(message, MESSAGE_INDENT);\n  stack = stack && !options.noStackTrace ? '\\n' + formatStackTrace(stack, config, options, testPath) : '';\n\n  if (blankStringRegexp.test(message) && blankStringRegexp.test(stack)) {\n    // this can happen if an empty object is thrown.\n    message = MESSAGE_INDENT + 'Error: No message was provided';\n  }\n\n  let messageToUse;\n\n  if (reuseMessage) {\n    messageToUse = ` ${message.trim()}`;\n  } else {\n    messageToUse = `${EXEC_ERROR_MESSAGE}\\n\\n${message}`;\n  }\n\n  return TITLE_INDENT + TITLE_BULLET + messageToUse + stack + '\\n';\n};\n\nexports.formatExecError = formatExecError;\n\nconst removeInternalStackEntries = (lines, options) => {\n  let pathCounter = 0;\n  return lines.filter(line => {\n    if (ANONYMOUS_FN_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (ANONYMOUS_PROMISE_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (ANONYMOUS_GENERATOR_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (NATIVE_NEXT_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (nodeInternals.some(internal => internal.test(line))) {\n      return false;\n    }\n\n    if (!STACK_PATH_REGEXP.test(line)) {\n      return true;\n    }\n\n    if (JASMINE_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (++pathCounter === 1) {\n      return true; // always keep the first line even if it's from Jest\n    }\n\n    if (options.noStackTrace) {\n      return false;\n    }\n\n    if (JEST_INTERNALS_IGNORE.test(line)) {\n      return false;\n    }\n\n    return true;\n  });\n};\n\nconst formatPaths = (config, relativeTestPath, line) => {\n  // Extract the file path from the trace line.\n  const match = line.match(/(^\\s*at .*?\\(?)([^()]+)(:[0-9]+:[0-9]+\\)?.*$)/);\n\n  if (!match) {\n    return line;\n  }\n\n  let filePath = (0, _slash.default)(_path.default.relative(config.rootDir, match[2])); // highlight paths from the current test file\n\n  if (config.testMatch && config.testMatch.length && _micromatch.default.some(filePath, config.testMatch) || filePath === relativeTestPath) {\n    filePath = _chalk.default.reset.cyan(filePath);\n  }\n\n  return STACK_TRACE_COLOR(match[1]) + filePath + STACK_TRACE_COLOR(match[3]);\n};\n\nconst getStackTraceLines = (stack, options = {\n  noStackTrace: false\n}) => removeInternalStackEntries(stack.split(/\\n/), options);\n\nexports.getStackTraceLines = getStackTraceLines;\n\nconst getTopFrame = lines => {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = lines[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      const line = _step.value;\n\n      if (line.includes(PATH_NODE_MODULES) || line.includes(PATH_JEST_PACKAGES)) {\n        continue;\n      }\n\n      const parsedFrame = stackUtils.parseLine(line.trim());\n\n      if (parsedFrame && parsedFrame.file) {\n        return parsedFrame;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return null;\n};\n\nexports.getTopFrame = getTopFrame;\n\nconst formatStackTrace = (stack, config, options, testPath) => {\n  const lines = getStackTraceLines(stack, options);\n  const topFrame = getTopFrame(lines);\n  let renderedCallsite = '';\n  const relativeTestPath = testPath ? (0, _slash.default)(_path.default.relative(config.rootDir, testPath)) : null;\n\n  if (topFrame) {\n    const column = topFrame.column,\n          filename = topFrame.file,\n          line = topFrame.line;\n\n    if (line && filename && _path.default.isAbsolute(filename)) {\n      let fileContent;\n\n      try {\n        // TODO: check & read HasteFS instead of reading the filesystem:\n        // see: https://github.com/facebook/jest/pull/5405#discussion_r164281696\n        fileContent = jestReadFile(filename, 'utf8');\n        renderedCallsite = getRenderedCallsite(fileContent, line, column);\n      } catch (e) {// the file does not exist or is inaccessible, we ignore\n      }\n    }\n  }\n\n  const stacktrace = lines.filter(Boolean).map(line => STACK_INDENT + formatPaths(config, relativeTestPath, trimPaths(line))).join('\\n');\n  return `${renderedCallsite}\\n${stacktrace}`;\n};\n\nexports.formatStackTrace = formatStackTrace;\n\nconst formatResultsErrors = (testResults, config, options, testPath) => {\n  const failedResults = testResults.reduce((errors, result) => {\n    result.failureMessages.forEach(content => errors.push({\n      content,\n      result\n    }));\n    return errors;\n  }, []);\n\n  if (!failedResults.length) {\n    return null;\n  }\n\n  return failedResults.map(({\n    result,\n    content\n  }) => {\n    let _separateMessageFromS = separateMessageFromStack(content),\n        message = _separateMessageFromS.message,\n        stack = _separateMessageFromS.stack;\n\n    stack = options.noStackTrace ? '' : STACK_TRACE_COLOR(formatStackTrace(stack, config, options, testPath)) + '\\n';\n    message = indentAllLines(message, MESSAGE_INDENT);\n    const title = _chalk.default.bold.red(TITLE_INDENT + TITLE_BULLET + result.ancestorTitles.join(ANCESTRY_SEPARATOR) + (result.ancestorTitles.length ? ANCESTRY_SEPARATOR : '') + result.title) + '\\n';\n    return title + '\\n' + message + '\\n' + stack;\n  }).join('\\n');\n};\n\nexports.formatResultsErrors = formatResultsErrors;\nconst errorRegexp = /^Error:?\\s*$/;\n\nconst removeBlankErrorLine = str => str.split('\\n') // Lines saying just `Error:` are useless\n.filter(line => !errorRegexp.test(line)).join('\\n').trimRight(); // jasmine and worker farm sometimes don't give us access to the actual\n// Error object, so we have to regexp out the message from the stack string\n// to format it.\n\n\nconst separateMessageFromStack = content => {\n  if (!content) {\n    return {\n      message: '',\n      stack: ''\n    };\n  } // All lines up to what looks like a stack -- or if nothing looks like a stack\n  // (maybe it's a code frame instead), just the first non-empty line.\n  // If the error is a plain \"Error:\" instead of a SyntaxError or TypeError we\n  // remove the prefix from the message because it is generally not useful.\n\n\n  const messageMatch = content.match(/^(?:Error: )?([\\s\\S]*?(?=\\n\\s*at\\s.*:\\d*:\\d*)|\\s*.*)([\\s\\S]*)$/);\n\n  if (!messageMatch) {\n    // For typescript\n    throw new Error('If you hit this error, the regex above is buggy.');\n  }\n\n  const message = removeBlankErrorLine(messageMatch[1]);\n  const stack = removeBlankErrorLine(messageMatch[2]);\n  return {\n    message,\n    stack\n  };\n};\n\nexports.separateMessageFromStack = separateMessageFromStack;","map":{"version":3,"sources":["C:/Users/lykam/Desktop/Senior Project/team05_react_app/node_modules/jest-message-util/build/index.js"],"names":["Object","defineProperty","exports","value","enumerable","get","_types","Frame","separateMessageFromStack","formatResultsErrors","formatStackTrace","getTopFrame","getStackTraceLines","formatExecError","_fs","_interopRequireDefault","require","_path","_chalk","_micromatch","_slash","_codeFrame","_stackUtils","obj","__esModule","default","Symbol","global","jestReadFile","for","readFileSync","stackUtils","cwd","nodeInternals","e","PATH_NODE_MODULES","sep","PATH_JEST_PACKAGES","JASMINE_IGNORE","JEST_INTERNALS_IGNORE","ANONYMOUS_FN_IGNORE","ANONYMOUS_PROMISE_IGNORE","ANONYMOUS_GENERATOR_IGNORE","NATIVE_NEXT_IGNORE","TITLE_INDENT","MESSAGE_INDENT","STACK_INDENT","ANCESTRY_SEPARATOR","TITLE_BULLET","bold","STACK_TRACE_COLOR","dim","STACK_PATH_REGEXP","EXEC_ERROR_MESSAGE","NOT_EMPTY_LINE_REGEXP","indentAllLines","lines","indent","replace","trim","string","trimPaths","match","getRenderedCallsite","fileContent","line","column","renderedCallsite","codeFrameColumns","start","highlightCode","blankStringRegexp","error","config","options","testPath","reuseMessage","Error","String","stack","message","separated","includes","noStackTrace","test","messageToUse","removeInternalStackEntries","pathCounter","filter","some","internal","formatPaths","relativeTestPath","filePath","relative","rootDir","testMatch","length","reset","cyan","split","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","iterator","_step","next","done","parsedFrame","parseLine","file","err","return","topFrame","filename","isAbsolute","stacktrace","Boolean","map","join","testResults","failedResults","reduce","errors","result","failureMessages","forEach","content","push","_separateMessageFromS","title","red","ancestorTitles","errorRegexp","removeBlankErrorLine","str","trimRight","messageMatch"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nObject.defineProperty(exports, '__esModule', {\r\n  value: true\r\n});\r\nObject.defineProperty(exports, 'Frame', {\r\n  enumerable: true,\r\n  get: function get() {\r\n    return _types.Frame;\r\n  }\r\n});\r\nexports.separateMessageFromStack = exports.formatResultsErrors = exports.formatStackTrace = exports.getTopFrame = exports.getStackTraceLines = exports.formatExecError = void 0;\r\n\r\nvar _fs = _interopRequireDefault(require('fs'));\r\n\r\nvar _path = _interopRequireDefault(require('path'));\r\n\r\nvar _chalk = _interopRequireDefault(require('chalk'));\r\n\r\nvar _micromatch = _interopRequireDefault(require('micromatch'));\r\n\r\nvar _slash = _interopRequireDefault(require('slash'));\r\n\r\nvar _codeFrame = require('@babel/code-frame');\r\n\r\nvar _stackUtils = _interopRequireDefault(require('stack-utils'));\r\n\r\nvar _types = require('./types');\r\n\r\nfunction _interopRequireDefault(obj) {\r\n  return obj && obj.__esModule ? obj : {default: obj};\r\n}\r\n\r\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\r\n\r\nvar jestReadFile =\r\n  global[Symbol.for('jest-native-read-file')] || _fs.default.readFileSync;\r\n\r\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\r\n// stack utils tries to create pretty stack by making paths relative.\r\nconst stackUtils = new _stackUtils.default({\r\n  cwd: 'something which does not exist'\r\n});\r\nlet nodeInternals = [];\r\n\r\ntry {\r\n  nodeInternals = _stackUtils.default.nodeInternals();\r\n} catch (e) {\r\n  // `StackUtils.nodeInternals()` fails in browsers. We don't need to remove\r\n  // node internals in the browser though, so no issue.\r\n}\r\n\r\nconst PATH_NODE_MODULES = `${_path.default.sep}node_modules${_path.default.sep}`;\r\nconst PATH_JEST_PACKAGES = `${_path.default.sep}jest${_path.default.sep}packages${_path.default.sep}`; // filter for noisy stack trace lines\r\n\r\nconst JASMINE_IGNORE = /^\\s+at(?:(?:.jasmine\\-)|\\s+jasmine\\.buildExpectationResult)/;\r\nconst JEST_INTERNALS_IGNORE = /^\\s+at.*?jest(-.*?)?(\\/|\\\\)(build|node_modules|packages)(\\/|\\\\)/;\r\nconst ANONYMOUS_FN_IGNORE = /^\\s+at <anonymous>.*$/;\r\nconst ANONYMOUS_PROMISE_IGNORE = /^\\s+at (new )?Promise \\(<anonymous>\\).*$/;\r\nconst ANONYMOUS_GENERATOR_IGNORE = /^\\s+at Generator.next \\(<anonymous>\\).*$/;\r\nconst NATIVE_NEXT_IGNORE = /^\\s+at next \\(native\\).*$/;\r\nconst TITLE_INDENT = '  ';\r\nconst MESSAGE_INDENT = '    ';\r\nconst STACK_INDENT = '      ';\r\nconst ANCESTRY_SEPARATOR = ' \\u203A ';\r\n\r\nconst TITLE_BULLET = _chalk.default.bold('\\u25cf ');\r\n\r\nconst STACK_TRACE_COLOR = _chalk.default.dim;\r\nconst STACK_PATH_REGEXP = /\\s*at.*\\(?(\\:\\d*\\:\\d*|native)\\)?/;\r\nconst EXEC_ERROR_MESSAGE = 'Test suite failed to run';\r\nconst NOT_EMPTY_LINE_REGEXP = /^(?!$)/gm;\r\n\r\nconst indentAllLines = (lines, indent) =>\r\n  lines.replace(NOT_EMPTY_LINE_REGEXP, indent);\r\n\r\nconst trim = string => (string || '').trim(); // Some errors contain not only line numbers in stack traces\r\n// e.g. SyntaxErrors can contain snippets of code, and we don't\r\n// want to trim those, because they may have pointers to the column/character\r\n// which will get misaligned.\r\n\r\nconst trimPaths = string =>\r\n  string.match(STACK_PATH_REGEXP) ? trim(string) : string;\r\n\r\nconst getRenderedCallsite = (fileContent, line, column) => {\r\n  let renderedCallsite = (0, _codeFrame.codeFrameColumns)(\r\n    fileContent,\r\n    {\r\n      start: {\r\n        column,\r\n        line\r\n      }\r\n    },\r\n    {\r\n      highlightCode: true\r\n    }\r\n  );\r\n  renderedCallsite = indentAllLines(renderedCallsite, MESSAGE_INDENT);\r\n  renderedCallsite = `\\n${renderedCallsite}\\n`;\r\n  return renderedCallsite;\r\n};\r\n\r\nconst blankStringRegexp = /^\\s*$/; // ExecError is an error thrown outside of the test suite (not inside an `it` or\r\n// `before/after each` hooks). If it's thrown, none of the tests in the file\r\n// are executed.\r\n\r\nconst formatExecError = (error, config, options, testPath, reuseMessage) => {\r\n  if (!error || typeof error === 'number') {\r\n    error = new Error(`Expected an Error, but \"${String(error)}\" was thrown`);\r\n    error.stack = '';\r\n  }\r\n\r\n  let message, stack;\r\n\r\n  if (typeof error === 'string' || !error) {\r\n    error || (error = 'EMPTY ERROR');\r\n    message = '';\r\n    stack = error;\r\n  } else {\r\n    message = error.message;\r\n    stack = error.stack;\r\n  }\r\n\r\n  const separated = separateMessageFromStack(stack || '');\r\n  stack = separated.stack;\r\n\r\n  if (separated.message.includes(trim(message))) {\r\n    // Often stack trace already contains the duplicate of the message\r\n    message = separated.message;\r\n  }\r\n\r\n  message = indentAllLines(message, MESSAGE_INDENT);\r\n  stack =\r\n    stack && !options.noStackTrace\r\n      ? '\\n' + formatStackTrace(stack, config, options, testPath)\r\n      : '';\r\n\r\n  if (blankStringRegexp.test(message) && blankStringRegexp.test(stack)) {\r\n    // this can happen if an empty object is thrown.\r\n    message = MESSAGE_INDENT + 'Error: No message was provided';\r\n  }\r\n\r\n  let messageToUse;\r\n\r\n  if (reuseMessage) {\r\n    messageToUse = ` ${message.trim()}`;\r\n  } else {\r\n    messageToUse = `${EXEC_ERROR_MESSAGE}\\n\\n${message}`;\r\n  }\r\n\r\n  return TITLE_INDENT + TITLE_BULLET + messageToUse + stack + '\\n';\r\n};\r\n\r\nexports.formatExecError = formatExecError;\r\n\r\nconst removeInternalStackEntries = (lines, options) => {\r\n  let pathCounter = 0;\r\n  return lines.filter(line => {\r\n    if (ANONYMOUS_FN_IGNORE.test(line)) {\r\n      return false;\r\n    }\r\n\r\n    if (ANONYMOUS_PROMISE_IGNORE.test(line)) {\r\n      return false;\r\n    }\r\n\r\n    if (ANONYMOUS_GENERATOR_IGNORE.test(line)) {\r\n      return false;\r\n    }\r\n\r\n    if (NATIVE_NEXT_IGNORE.test(line)) {\r\n      return false;\r\n    }\r\n\r\n    if (nodeInternals.some(internal => internal.test(line))) {\r\n      return false;\r\n    }\r\n\r\n    if (!STACK_PATH_REGEXP.test(line)) {\r\n      return true;\r\n    }\r\n\r\n    if (JASMINE_IGNORE.test(line)) {\r\n      return false;\r\n    }\r\n\r\n    if (++pathCounter === 1) {\r\n      return true; // always keep the first line even if it's from Jest\r\n    }\r\n\r\n    if (options.noStackTrace) {\r\n      return false;\r\n    }\r\n\r\n    if (JEST_INTERNALS_IGNORE.test(line)) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  });\r\n};\r\n\r\nconst formatPaths = (config, relativeTestPath, line) => {\r\n  // Extract the file path from the trace line.\r\n  const match = line.match(/(^\\s*at .*?\\(?)([^()]+)(:[0-9]+:[0-9]+\\)?.*$)/);\r\n\r\n  if (!match) {\r\n    return line;\r\n  }\r\n\r\n  let filePath = (0, _slash.default)(\r\n    _path.default.relative(config.rootDir, match[2])\r\n  ); // highlight paths from the current test file\r\n\r\n  if (\r\n    (config.testMatch &&\r\n      config.testMatch.length &&\r\n      _micromatch.default.some(filePath, config.testMatch)) ||\r\n    filePath === relativeTestPath\r\n  ) {\r\n    filePath = _chalk.default.reset.cyan(filePath);\r\n  }\r\n\r\n  return STACK_TRACE_COLOR(match[1]) + filePath + STACK_TRACE_COLOR(match[3]);\r\n};\r\n\r\nconst getStackTraceLines = (\r\n  stack,\r\n  options = {\r\n    noStackTrace: false\r\n  }\r\n) => removeInternalStackEntries(stack.split(/\\n/), options);\r\n\r\nexports.getStackTraceLines = getStackTraceLines;\r\n\r\nconst getTopFrame = lines => {\r\n  var _iteratorNormalCompletion = true;\r\n  var _didIteratorError = false;\r\n  var _iteratorError = undefined;\r\n\r\n  try {\r\n    for (\r\n      var _iterator = lines[Symbol.iterator](), _step;\r\n      !(_iteratorNormalCompletion = (_step = _iterator.next()).done);\r\n      _iteratorNormalCompletion = true\r\n    ) {\r\n      const line = _step.value;\r\n\r\n      if (\r\n        line.includes(PATH_NODE_MODULES) ||\r\n        line.includes(PATH_JEST_PACKAGES)\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      const parsedFrame = stackUtils.parseLine(line.trim());\r\n\r\n      if (parsedFrame && parsedFrame.file) {\r\n        return parsedFrame;\r\n      }\r\n    }\r\n  } catch (err) {\r\n    _didIteratorError = true;\r\n    _iteratorError = err;\r\n  } finally {\r\n    try {\r\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\r\n        _iterator.return();\r\n      }\r\n    } finally {\r\n      if (_didIteratorError) {\r\n        throw _iteratorError;\r\n      }\r\n    }\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\nexports.getTopFrame = getTopFrame;\r\n\r\nconst formatStackTrace = (stack, config, options, testPath) => {\r\n  const lines = getStackTraceLines(stack, options);\r\n  const topFrame = getTopFrame(lines);\r\n  let renderedCallsite = '';\r\n  const relativeTestPath = testPath\r\n    ? (0, _slash.default)(_path.default.relative(config.rootDir, testPath))\r\n    : null;\r\n\r\n  if (topFrame) {\r\n    const column = topFrame.column,\r\n      filename = topFrame.file,\r\n      line = topFrame.line;\r\n\r\n    if (line && filename && _path.default.isAbsolute(filename)) {\r\n      let fileContent;\r\n\r\n      try {\r\n        // TODO: check & read HasteFS instead of reading the filesystem:\r\n        // see: https://github.com/facebook/jest/pull/5405#discussion_r164281696\r\n        fileContent = jestReadFile(filename, 'utf8');\r\n        renderedCallsite = getRenderedCallsite(fileContent, line, column);\r\n      } catch (e) {\r\n        // the file does not exist or is inaccessible, we ignore\r\n      }\r\n    }\r\n  }\r\n\r\n  const stacktrace = lines\r\n    .filter(Boolean)\r\n    .map(\r\n      line =>\r\n        STACK_INDENT + formatPaths(config, relativeTestPath, trimPaths(line))\r\n    )\r\n    .join('\\n');\r\n  return `${renderedCallsite}\\n${stacktrace}`;\r\n};\r\n\r\nexports.formatStackTrace = formatStackTrace;\r\n\r\nconst formatResultsErrors = (testResults, config, options, testPath) => {\r\n  const failedResults = testResults.reduce((errors, result) => {\r\n    result.failureMessages.forEach(content =>\r\n      errors.push({\r\n        content,\r\n        result\r\n      })\r\n    );\r\n    return errors;\r\n  }, []);\r\n\r\n  if (!failedResults.length) {\r\n    return null;\r\n  }\r\n\r\n  return failedResults\r\n    .map(({result, content}) => {\r\n      let _separateMessageFromS = separateMessageFromStack(content),\r\n        message = _separateMessageFromS.message,\r\n        stack = _separateMessageFromS.stack;\r\n\r\n      stack = options.noStackTrace\r\n        ? ''\r\n        : STACK_TRACE_COLOR(\r\n            formatStackTrace(stack, config, options, testPath)\r\n          ) + '\\n';\r\n      message = indentAllLines(message, MESSAGE_INDENT);\r\n      const title =\r\n        _chalk.default.bold.red(\r\n          TITLE_INDENT +\r\n            TITLE_BULLET +\r\n            result.ancestorTitles.join(ANCESTRY_SEPARATOR) +\r\n            (result.ancestorTitles.length ? ANCESTRY_SEPARATOR : '') +\r\n            result.title\r\n        ) + '\\n';\r\n      return title + '\\n' + message + '\\n' + stack;\r\n    })\r\n    .join('\\n');\r\n};\r\n\r\nexports.formatResultsErrors = formatResultsErrors;\r\nconst errorRegexp = /^Error:?\\s*$/;\r\n\r\nconst removeBlankErrorLine = str =>\r\n  str\r\n    .split('\\n') // Lines saying just `Error:` are useless\r\n    .filter(line => !errorRegexp.test(line))\r\n    .join('\\n')\r\n    .trimRight(); // jasmine and worker farm sometimes don't give us access to the actual\r\n// Error object, so we have to regexp out the message from the stack string\r\n// to format it.\r\n\r\nconst separateMessageFromStack = content => {\r\n  if (!content) {\r\n    return {\r\n      message: '',\r\n      stack: ''\r\n    };\r\n  } // All lines up to what looks like a stack -- or if nothing looks like a stack\r\n  // (maybe it's a code frame instead), just the first non-empty line.\r\n  // If the error is a plain \"Error:\" instead of a SyntaxError or TypeError we\r\n  // remove the prefix from the message because it is generally not useful.\r\n\r\n  const messageMatch = content.match(\r\n    /^(?:Error: )?([\\s\\S]*?(?=\\n\\s*at\\s.*:\\d*:\\d*)|\\s*.*)([\\s\\S]*)$/\r\n  );\r\n\r\n  if (!messageMatch) {\r\n    // For typescript\r\n    throw new Error('If you hit this error, the regex above is buggy.');\r\n  }\r\n\r\n  const message = removeBlankErrorLine(messageMatch[1]);\r\n  const stack = removeBlankErrorLine(messageMatch[2]);\r\n  return {\r\n    message,\r\n    stack\r\n  };\r\n};\r\n\r\nexports.separateMessageFromStack = separateMessageFromStack;\r\n"]},"metadata":{},"sourceType":"script"}