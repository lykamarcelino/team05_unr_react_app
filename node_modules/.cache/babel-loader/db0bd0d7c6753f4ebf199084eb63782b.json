{"ast":null,"code":"'use strict';\n/**\r\n * Module dependencies\r\n */\n\nvar util = require('util');\n\nvar toRegex = require('to-regex');\n\nvar extend = require('extend-shallow');\n/**\r\n * Local dependencies\r\n */\n\n\nvar compilers = require('./lib/compilers');\n\nvar parsers = require('./lib/parsers');\n\nvar cache = require('./lib/cache');\n\nvar utils = require('./lib/utils');\n\nvar MAX_LENGTH = 1024 * 64;\n/**\r\n * The main function takes a list of strings and one or more\r\n * glob patterns to use for matching.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm(list, patterns[, options]);\r\n *\r\n * console.log(nm(['a.js', 'a.txt'], ['*.js']));\r\n * //=> [ 'a.js' ]\r\n * ```\r\n * @param {Array} `list` A list of strings to match\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Array} Returns an array of matches\r\n * @summary false\r\n * @api public\r\n */\n\nfunction nanomatch(list, patterns, options) {\n  patterns = utils.arrayify(patterns);\n  list = utils.arrayify(list);\n  var len = patterns.length;\n\n  if (list.length === 0 || len === 0) {\n    return [];\n  }\n\n  if (len === 1) {\n    return nanomatch.match(list, patterns[0], options);\n  }\n\n  var negated = false;\n  var omit = [];\n  var keep = [];\n  var idx = -1;\n\n  while (++idx < len) {\n    var pattern = patterns[idx];\n\n    if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33\n    /* ! */\n    ) {\n        omit.push.apply(omit, nanomatch.match(list, pattern.slice(1), options));\n        negated = true;\n      } else {\n      keep.push.apply(keep, nanomatch.match(list, pattern, options));\n    }\n  } // minimatch.match parity\n\n\n  if (negated && keep.length === 0) {\n    if (options && options.unixify === false) {\n      keep = list.slice();\n    } else {\n      var unixify = utils.unixify(options);\n\n      for (var i = 0; i < list.length; i++) {\n        keep.push(unixify(list[i]));\n      }\n    }\n  }\n\n  var matches = utils.diff(keep, omit);\n\n  if (!options || options.nodupes !== false) {\n    return utils.unique(matches);\n  }\n\n  return matches;\n}\n/**\r\n * Similar to the main function, but `pattern` must be a string.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.match(list, pattern[, options]);\r\n *\r\n * console.log(nm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));\r\n * //=> ['a.a', 'a.aa']\r\n * ```\r\n * @param {Array} `list` Array of strings to match\r\n * @param {String} `pattern` Glob pattern to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Array} Returns an array of matches\r\n * @api public\r\n */\n\n\nnanomatch.match = function (list, pattern, options) {\n  if (Array.isArray(pattern)) {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  var unixify = utils.unixify(options);\n  var isMatch = memoize('match', pattern, options, nanomatch.matcher);\n  var matches = [];\n  list = utils.arrayify(list);\n  var len = list.length;\n  var idx = -1;\n\n  while (++idx < len) {\n    var ele = list[idx];\n\n    if (ele === pattern || isMatch(ele)) {\n      matches.push(utils.value(ele, unixify, options));\n    }\n  } // if no options were passed, uniquify results and return\n\n\n  if (typeof options === 'undefined') {\n    return utils.unique(matches);\n  }\n\n  if (matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error('no matches found for \"' + pattern + '\"');\n    }\n\n    if (options.nonull === true || options.nullglob === true) {\n      return [options.unescape ? utils.unescape(pattern) : pattern];\n    }\n  } // if `opts.ignore` was defined, diff ignored list\n\n\n  if (options.ignore) {\n    matches = nanomatch.not(matches, options.ignore, options);\n  }\n\n  return options.nodupes !== false ? utils.unique(matches) : matches;\n};\n/**\r\n * Returns true if the specified `string` matches the given glob `pattern`.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.isMatch(string, pattern[, options]);\r\n *\r\n * console.log(nm.isMatch('a.a', '*.a'));\r\n * //=> true\r\n * console.log(nm.isMatch('a.b', '*.a'));\r\n * //=> false\r\n * ```\r\n * @param {String} `string` String to match\r\n * @param {String} `pattern` Glob pattern to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if the string matches the glob pattern.\r\n * @api public\r\n */\n\n\nnanomatch.isMatch = function (str, pattern, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (utils.isEmptyString(str) || utils.isEmptyString(pattern)) {\n    return false;\n  }\n\n  var equals = utils.equalsPattern(options);\n\n  if (equals(str)) {\n    return true;\n  }\n\n  var isMatch = memoize('isMatch', pattern, options, nanomatch.matcher);\n  return isMatch(str);\n};\n/**\r\n * Returns true if some of the elements in the given `list` match any of the\r\n * given glob `patterns`.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.some(list, patterns[, options]);\r\n *\r\n * console.log(nm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\r\n * // true\r\n * console.log(nm.some(['foo.js'], ['*.js', '!foo.js']));\r\n * // false\r\n * ```\r\n * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if any patterns match `str`\r\n * @api public\r\n */\n\n\nnanomatch.some = function (list, patterns, options) {\n  if (typeof list === 'string') {\n    list = [list];\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    if (nanomatch(list[i], patterns, options).length === 1) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\r\n * Returns true if every element in the given `list` matches\r\n * at least one of the given glob `patterns`.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.every(list, patterns[, options]);\r\n *\r\n * console.log(nm.every('foo.js', ['foo.js']));\r\n * // true\r\n * console.log(nm.every(['foo.js', 'bar.js'], ['*.js']));\r\n * // true\r\n * console.log(nm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\r\n * // false\r\n * console.log(nm.every(['foo.js'], ['*.js', '!foo.js']));\r\n * // false\r\n * ```\r\n * @param  {String|Array} `list` The string or array of strings to test.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if any patterns match `str`\r\n * @api public\r\n */\n\n\nnanomatch.every = function (list, patterns, options) {\n  if (typeof list === 'string') {\n    list = [list];\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    if (nanomatch(list[i], patterns, options).length !== 1) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\r\n * Returns true if **any** of the given glob `patterns`\r\n * match the specified `string`.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.any(string, patterns[, options]);\r\n *\r\n * console.log(nm.any('a.a', ['b.*', '*.a']));\r\n * //=> true\r\n * console.log(nm.any('a.a', 'b.*'));\r\n * //=> false\r\n * ```\r\n * @param  {String|Array} `str` The string to test.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if any patterns match `str`\r\n * @api public\r\n */\n\n\nnanomatch.any = function (str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {\n    return false;\n  }\n\n  if (typeof patterns === 'string') {\n    patterns = [patterns];\n  }\n\n  for (var i = 0; i < patterns.length; i++) {\n    if (nanomatch.isMatch(str, patterns[i], options)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\r\n * Returns true if **all** of the given `patterns`\r\n * match the specified string.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.all(string, patterns[, options]);\r\n *\r\n * console.log(nm.all('foo.js', ['foo.js']));\r\n * // true\r\n *\r\n * console.log(nm.all('foo.js', ['*.js', '!foo.js']));\r\n * // false\r\n *\r\n * console.log(nm.all('foo.js', ['*.js', 'foo.js']));\r\n * // true\r\n *\r\n * console.log(nm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\r\n * // true\r\n * ```\r\n * @param  {String|Array} `str` The string to test.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if any patterns match `str`\r\n * @api public\r\n */\n\n\nnanomatch.all = function (str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (typeof patterns === 'string') {\n    patterns = [patterns];\n  }\n\n  for (var i = 0; i < patterns.length; i++) {\n    if (!nanomatch.isMatch(str, patterns[i], options)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\r\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.not(list, patterns[, options]);\r\n *\r\n * console.log(nm.not(['a.a', 'b.b', 'c.c'], '*.a'));\r\n * //=> ['b.b', 'c.c']\r\n * ```\r\n * @param {Array} `list` Array of strings to match.\r\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\r\n * @api public\r\n */\n\n\nnanomatch.not = function (list, patterns, options) {\n  var opts = extend({}, options);\n  var ignore = opts.ignore;\n  delete opts.ignore;\n  list = utils.arrayify(list);\n  var matches = utils.diff(list, nanomatch(list, patterns, opts));\n\n  if (ignore) {\n    matches = utils.diff(matches, nanomatch(list, ignore));\n  }\n\n  return opts.nodupes !== false ? utils.unique(matches) : matches;\n};\n/**\r\n * Returns true if the given `string` contains the given pattern. Similar\r\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.contains(string, pattern[, options]);\r\n *\r\n * console.log(nm.contains('aa/bb/cc', '*b'));\r\n * //=> true\r\n * console.log(nm.contains('aa/bb/cc', '*d'));\r\n * //=> false\r\n * ```\r\n * @param {String} `str` The string to match.\r\n * @param {String|Array} `patterns` Glob pattern to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if the patter matches any part of `str`.\r\n * @api public\r\n */\n\n\nnanomatch.contains = function (str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (typeof patterns === 'string') {\n    if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {\n      return false;\n    }\n\n    var equals = utils.equalsPattern(patterns, options);\n\n    if (equals(str)) {\n      return true;\n    }\n\n    var contains = utils.containsPattern(patterns, options);\n\n    if (contains(str)) {\n      return true;\n    }\n  }\n\n  var opts = extend({}, options, {\n    contains: true\n  });\n  return nanomatch.any(str, patterns, opts);\n};\n/**\r\n * Returns true if the given pattern and options should enable\r\n * the `matchBase` option.\r\n * @return {Boolean}\r\n * @api private\r\n */\n\n\nnanomatch.matchBase = function (pattern, options) {\n  if (pattern && pattern.indexOf('/') !== -1 || !options) return false;\n  return options.basename === true || options.matchBase === true;\n};\n/**\r\n * Filter the keys of the given object with the given `glob` pattern\r\n * and `options`. Does not attempt to match nested keys. If you need this feature,\r\n * use [glob-object][] instead.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.matchKeys(object, patterns[, options]);\r\n *\r\n * var obj = { aa: 'a', ab: 'b', ac: 'c' };\r\n * console.log(nm.matchKeys(obj, '*b'));\r\n * //=> { ab: 'b' }\r\n * ```\r\n * @param {Object} `object` The object with keys to filter.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Object} Returns an object with only keys that match the given patterns.\r\n * @api public\r\n */\n\n\nnanomatch.matchKeys = function (obj, patterns, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('expected the first argument to be an object');\n  }\n\n  var keys = nanomatch(Object.keys(obj), patterns, options);\n  return utils.pick(obj, keys);\n};\n/**\r\n * Returns a memoized matcher function from the given glob `pattern` and `options`.\r\n * The returned function takes a string to match as its only argument and returns\r\n * true if the string is a match.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.matcher(pattern[, options]);\r\n *\r\n * var isMatch = nm.matcher('*.!(*a)');\r\n * console.log(isMatch('a.a'));\r\n * //=> false\r\n * console.log(isMatch('a.b'));\r\n * //=> true\r\n * ```\r\n * @param {String} `pattern` Glob pattern\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\r\n * @return {Function} Returns a matcher function.\r\n * @api public\r\n */\n\n\nnanomatch.matcher = function matcher(pattern, options) {\n  if (utils.isEmptyString(pattern)) {\n    return function () {\n      return false;\n    };\n  }\n\n  if (Array.isArray(pattern)) {\n    return compose(pattern, options, matcher);\n  } // if pattern is a regex\n\n\n  if (pattern instanceof RegExp) {\n    return test(pattern);\n  } // if pattern is invalid\n\n\n  if (!utils.isString(pattern)) {\n    throw new TypeError('expected pattern to be an array, string or regex');\n  } // if pattern is a non-glob string\n\n\n  if (!utils.hasSpecialChars(pattern)) {\n    if (options && options.nocase === true) {\n      pattern = pattern.toLowerCase();\n    }\n\n    return utils.matchPath(pattern, options);\n  } // if pattern is a glob string\n\n\n  var re = nanomatch.makeRe(pattern, options); // if `options.matchBase` or `options.basename` is defined\n\n  if (nanomatch.matchBase(pattern, options)) {\n    return utils.matchBasename(re, options);\n  }\n\n  function test(regex) {\n    var equals = utils.equalsPattern(options);\n    var unixify = utils.unixify(options);\n    return function (str) {\n      if (equals(str)) {\n        return true;\n      }\n\n      if (regex.test(unixify(str))) {\n        return true;\n      }\n\n      return false;\n    };\n  } // create matcher function\n\n\n  var matcherFn = test(re); // set result object from compiler on matcher function,\n  // as a non-enumerable property. useful for debugging\n\n  utils.define(matcherFn, 'result', re.result);\n  return matcherFn;\n};\n/**\r\n * Returns an array of matches captured by `pattern` in `string, or\r\n * `null` if the pattern did not match.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.capture(pattern, string[, options]);\r\n *\r\n * console.log(nm.capture('test/*.js', 'test/foo.js'));\r\n * //=> ['foo']\r\n * console.log(nm.capture('test/*.js', 'foo/bar.css'));\r\n * //=> null\r\n * ```\r\n * @param {String} `pattern` Glob pattern to use for matching.\r\n * @param {String} `string` String to match\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.\r\n * @api public\r\n */\n\n\nnanomatch.capture = function (pattern, str, options) {\n  var re = nanomatch.makeRe(pattern, extend({\n    capture: true\n  }, options));\n  var unixify = utils.unixify(options);\n\n  function match() {\n    return function (string) {\n      var match = re.exec(unixify(string));\n\n      if (!match) {\n        return null;\n      }\n\n      return match.slice(1);\n    };\n  }\n\n  var capture = memoize('capture', pattern, options, match);\n  return capture(str);\n};\n/**\r\n * Create a regular expression from the given glob `pattern`.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.makeRe(pattern[, options]);\r\n *\r\n * console.log(nm.makeRe('*.js'));\r\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\r\n * ```\r\n * @param {String} `pattern` A glob pattern to convert to regex.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\r\n * @return {RegExp} Returns a regex created from the given pattern.\r\n * @api public\r\n */\n\n\nnanomatch.makeRe = function (pattern, options) {\n  if (pattern instanceof RegExp) {\n    return pattern;\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  if (pattern.length > MAX_LENGTH) {\n    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');\n  }\n\n  function makeRe() {\n    var opts = utils.extend({\n      wrap: false\n    }, options);\n    var result = nanomatch.create(pattern, opts);\n    var regex = toRegex(result.output, opts);\n    utils.define(regex, 'result', result);\n    return regex;\n  }\n\n  return memoize('makeRe', pattern, options, makeRe);\n};\n/**\r\n * Parses the given glob `pattern` and returns an object with the compiled `output`\r\n * and optional source `map`.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.create(pattern[, options]);\r\n *\r\n * console.log(nm.create('abc/*.js'));\r\n * // { options: { source: 'string', sourcemap: true },\r\n * //   state: {},\r\n * //   compilers:\r\n * //    { ... },\r\n * //   output: '(\\\\.[\\\\\\\\\\\\/])?abc\\\\/(?!\\\\.)(?=.)[^\\\\/]*?\\\\.js',\r\n * //   ast:\r\n * //    { type: 'root',\r\n * //      errors: [],\r\n * //      nodes:\r\n * //       [ ... ],\r\n * //      dot: false,\r\n * //      input: 'abc/*.js' },\r\n * //   parsingErrors: [],\r\n * //   map:\r\n * //    { version: 3,\r\n * //      sources: [ 'string' ],\r\n * //      names: [],\r\n * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',\r\n * //      sourcesContent: [ 'abc/*.js' ] },\r\n * //   position: { line: 1, column: 28 },\r\n * //   content: {},\r\n * //   files: {},\r\n * //   idx: 6 }\r\n * ```\r\n * @param {String} `pattern` Glob pattern to parse and compile.\r\n * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.\r\n * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.\r\n * @api public\r\n */\n\n\nnanomatch.create = function (pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  function create() {\n    return nanomatch.compile(nanomatch.parse(pattern, options), options);\n  }\n\n  return memoize('create', pattern, options, create);\n};\n/**\r\n * Parse the given `str` with the given `options`.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.parse(pattern[, options]);\r\n *\r\n * var ast = nm.parse('a/{b,c}/d');\r\n * console.log(ast);\r\n * // { type: 'root',\r\n * //   errors: [],\r\n * //   input: 'a/{b,c}/d',\r\n * //   nodes:\r\n * //    [ { type: 'bos', val: '' },\r\n * //      { type: 'text', val: 'a/' },\r\n * //      { type: 'brace',\r\n * //        nodes:\r\n * //         [ { type: 'brace.open', val: '{' },\r\n * //           { type: 'text', val: 'b,c' },\r\n * //           { type: 'brace.close', val: '}' } ] },\r\n * //      { type: 'text', val: '/d' },\r\n * //      { type: 'eos', val: '' } ] }\r\n * ```\r\n * @param {String} `str`\r\n * @param {Object} `options`\r\n * @return {Object} Returns an AST\r\n * @api public\r\n */\n\n\nnanomatch.parse = function (pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  function parse() {\n    var snapdragon = utils.instantiate(null, options);\n    parsers(snapdragon, options);\n    var ast = snapdragon.parse(pattern, options);\n    utils.define(ast, 'snapdragon', snapdragon);\n    ast.input = pattern;\n    return ast;\n  }\n\n  return memoize('parse', pattern, options, parse);\n};\n/**\r\n * Compile the given `ast` or string with the given `options`.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.compile(ast[, options]);\r\n *\r\n * var ast = nm.parse('a/{b,c}/d');\r\n * console.log(nm.compile(ast));\r\n * // { options: { source: 'string' },\r\n * //   state: {},\r\n * //   compilers:\r\n * //    { eos: [Function],\r\n * //      noop: [Function],\r\n * //      bos: [Function],\r\n * //      brace: [Function],\r\n * //      'brace.open': [Function],\r\n * //      text: [Function],\r\n * //      'brace.close': [Function] },\r\n * //   output: [ 'a/(b|c)/d' ],\r\n * //   ast:\r\n * //    { ... },\r\n * //   parsingErrors: [] }\r\n * ```\r\n * @param {Object|String} `ast`\r\n * @param {Object} `options`\r\n * @return {Object} Returns an object that has an `output` property with the compiled string.\r\n * @api public\r\n */\n\n\nnanomatch.compile = function (ast, options) {\n  if (typeof ast === 'string') {\n    ast = nanomatch.parse(ast, options);\n  }\n\n  function compile() {\n    var snapdragon = utils.instantiate(ast, options);\n    compilers(snapdragon, options);\n    return snapdragon.compile(ast, options);\n  }\n\n  return memoize('compile', ast.input, options, compile);\n};\n/**\r\n * Clear the regex cache.\r\n *\r\n * ```js\r\n * nm.clearCache();\r\n * ```\r\n * @api public\r\n */\n\n\nnanomatch.clearCache = function () {\n  nanomatch.cache.__data__ = {};\n};\n/**\r\n * Compose a matcher function with the given patterns.\r\n * This allows matcher functions to be compiled once and\r\n * called multiple times.\r\n */\n\n\nfunction compose(patterns, options, matcher) {\n  var matchers;\n  return memoize('compose', String(patterns), options, function () {\n    return function (file) {\n      // delay composition until it's invoked the first time,\n      // after that it won't be called again\n      if (!matchers) {\n        matchers = [];\n\n        for (var i = 0; i < patterns.length; i++) {\n          matchers.push(matcher(patterns[i], options));\n        }\n      }\n\n      var len = matchers.length;\n\n      while (len--) {\n        if (matchers[len](file) === true) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n  });\n}\n/**\r\n * Memoize a generated regex or function. A unique key is generated\r\n * from the `type` (usually method name), the `pattern`, and\r\n * user-defined options.\r\n */\n\n\nfunction memoize(type, pattern, options, fn) {\n  var key = utils.createKey(type + '=' + pattern, options);\n\n  if (options && options.cache === false) {\n    return fn(pattern, options);\n  }\n\n  if (cache.has(type, key)) {\n    return cache.get(type, key);\n  }\n\n  var val = fn(pattern, options);\n  cache.set(type, key, val);\n  return val;\n}\n/**\r\n * Expose compiler, parser and cache on `nanomatch`\r\n */\n\n\nnanomatch.compilers = compilers;\nnanomatch.parsers = parsers;\nnanomatch.cache = cache;\n/**\r\n * Expose `nanomatch`\r\n * @type {Function}\r\n */\n\nmodule.exports = nanomatch;","map":{"version":3,"sources":["C:/Users/lykam/Desktop/Senior Project/team05_react_app/node_modules/nanomatch/index.js"],"names":["util","require","toRegex","extend","compilers","parsers","cache","utils","MAX_LENGTH","nanomatch","list","patterns","options","arrayify","len","length","match","negated","omit","keep","idx","pattern","charCodeAt","push","apply","slice","unixify","i","matches","diff","nodupes","unique","Array","isArray","TypeError","isMatch","memoize","matcher","ele","value","failglob","Error","nonull","nullglob","unescape","ignore","not","str","inspect","isEmptyString","equals","equalsPattern","some","every","any","all","opts","contains","containsPattern","matchBase","indexOf","basename","matchKeys","obj","isObject","keys","Object","pick","compose","RegExp","test","isString","hasSpecialChars","nocase","toLowerCase","matchPath","re","makeRe","matchBasename","regex","matcherFn","define","result","capture","string","exec","wrap","create","output","compile","parse","snapdragon","instantiate","ast","input","clearCache","__data__","matchers","String","file","type","fn","key","createKey","has","get","val","set","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\n/**\r\n * Module dependencies\r\n */\r\n\r\nvar util = require('util');\r\nvar toRegex = require('to-regex');\r\nvar extend = require('extend-shallow');\r\n\r\n/**\r\n * Local dependencies\r\n */\r\n\r\nvar compilers = require('./lib/compilers');\r\nvar parsers = require('./lib/parsers');\r\nvar cache = require('./lib/cache');\r\nvar utils = require('./lib/utils');\r\nvar MAX_LENGTH = 1024 * 64;\r\n\r\n/**\r\n * The main function takes a list of strings and one or more\r\n * glob patterns to use for matching.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm(list, patterns[, options]);\r\n *\r\n * console.log(nm(['a.js', 'a.txt'], ['*.js']));\r\n * //=> [ 'a.js' ]\r\n * ```\r\n * @param {Array} `list` A list of strings to match\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Array} Returns an array of matches\r\n * @summary false\r\n * @api public\r\n */\r\n\r\nfunction nanomatch(list, patterns, options) {\r\n  patterns = utils.arrayify(patterns);\r\n  list = utils.arrayify(list);\r\n\r\n  var len = patterns.length;\r\n  if (list.length === 0 || len === 0) {\r\n    return [];\r\n  }\r\n\r\n  if (len === 1) {\r\n    return nanomatch.match(list, patterns[0], options);\r\n  }\r\n\r\n  var negated = false;\r\n  var omit = [];\r\n  var keep = [];\r\n  var idx = -1;\r\n\r\n  while (++idx < len) {\r\n    var pattern = patterns[idx];\r\n\r\n    if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33 /* ! */) {\r\n      omit.push.apply(omit, nanomatch.match(list, pattern.slice(1), options));\r\n      negated = true;\r\n    } else {\r\n      keep.push.apply(keep, nanomatch.match(list, pattern, options));\r\n    }\r\n  }\r\n\r\n  // minimatch.match parity\r\n  if (negated && keep.length === 0) {\r\n    if (options && options.unixify === false) {\r\n      keep = list.slice();\r\n    } else {\r\n      var unixify = utils.unixify(options);\r\n      for (var i = 0; i < list.length; i++) {\r\n        keep.push(unixify(list[i]));\r\n      }\r\n    }\r\n  }\r\n\r\n  var matches = utils.diff(keep, omit);\r\n  if (!options || options.nodupes !== false) {\r\n    return utils.unique(matches);\r\n  }\r\n\r\n  return matches;\r\n}\r\n\r\n/**\r\n * Similar to the main function, but `pattern` must be a string.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.match(list, pattern[, options]);\r\n *\r\n * console.log(nm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));\r\n * //=> ['a.a', 'a.aa']\r\n * ```\r\n * @param {Array} `list` Array of strings to match\r\n * @param {String} `pattern` Glob pattern to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Array} Returns an array of matches\r\n * @api public\r\n */\r\n\r\nnanomatch.match = function(list, pattern, options) {\r\n  if (Array.isArray(pattern)) {\r\n    throw new TypeError('expected pattern to be a string');\r\n  }\r\n\r\n  var unixify = utils.unixify(options);\r\n  var isMatch = memoize('match', pattern, options, nanomatch.matcher);\r\n  var matches = [];\r\n\r\n  list = utils.arrayify(list);\r\n  var len = list.length;\r\n  var idx = -1;\r\n\r\n  while (++idx < len) {\r\n    var ele = list[idx];\r\n    if (ele === pattern || isMatch(ele)) {\r\n      matches.push(utils.value(ele, unixify, options));\r\n    }\r\n  }\r\n\r\n  // if no options were passed, uniquify results and return\r\n  if (typeof options === 'undefined') {\r\n    return utils.unique(matches);\r\n  }\r\n\r\n  if (matches.length === 0) {\r\n    if (options.failglob === true) {\r\n      throw new Error('no matches found for \"' + pattern + '\"');\r\n    }\r\n    if (options.nonull === true || options.nullglob === true) {\r\n      return [options.unescape ? utils.unescape(pattern) : pattern];\r\n    }\r\n  }\r\n\r\n  // if `opts.ignore` was defined, diff ignored list\r\n  if (options.ignore) {\r\n    matches = nanomatch.not(matches, options.ignore, options);\r\n  }\r\n\r\n  return options.nodupes !== false ? utils.unique(matches) : matches;\r\n};\r\n\r\n/**\r\n * Returns true if the specified `string` matches the given glob `pattern`.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.isMatch(string, pattern[, options]);\r\n *\r\n * console.log(nm.isMatch('a.a', '*.a'));\r\n * //=> true\r\n * console.log(nm.isMatch('a.b', '*.a'));\r\n * //=> false\r\n * ```\r\n * @param {String} `string` String to match\r\n * @param {String} `pattern` Glob pattern to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if the string matches the glob pattern.\r\n * @api public\r\n */\r\n\r\nnanomatch.isMatch = function(str, pattern, options) {\r\n  if (typeof str !== 'string') {\r\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\r\n  }\r\n\r\n  if (utils.isEmptyString(str) || utils.isEmptyString(pattern)) {\r\n    return false;\r\n  }\r\n\r\n  var equals = utils.equalsPattern(options);\r\n  if (equals(str)) {\r\n    return true;\r\n  }\r\n\r\n  var isMatch = memoize('isMatch', pattern, options, nanomatch.matcher);\r\n  return isMatch(str);\r\n};\r\n\r\n/**\r\n * Returns true if some of the elements in the given `list` match any of the\r\n * given glob `patterns`.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.some(list, patterns[, options]);\r\n *\r\n * console.log(nm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\r\n * // true\r\n * console.log(nm.some(['foo.js'], ['*.js', '!foo.js']));\r\n * // false\r\n * ```\r\n * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if any patterns match `str`\r\n * @api public\r\n */\r\n\r\nnanomatch.some = function(list, patterns, options) {\r\n  if (typeof list === 'string') {\r\n    list = [list];\r\n  }\r\n\r\n  for (var i = 0; i < list.length; i++) {\r\n    if (nanomatch(list[i], patterns, options).length === 1) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * Returns true if every element in the given `list` matches\r\n * at least one of the given glob `patterns`.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.every(list, patterns[, options]);\r\n *\r\n * console.log(nm.every('foo.js', ['foo.js']));\r\n * // true\r\n * console.log(nm.every(['foo.js', 'bar.js'], ['*.js']));\r\n * // true\r\n * console.log(nm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\r\n * // false\r\n * console.log(nm.every(['foo.js'], ['*.js', '!foo.js']));\r\n * // false\r\n * ```\r\n * @param  {String|Array} `list` The string or array of strings to test.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if any patterns match `str`\r\n * @api public\r\n */\r\n\r\nnanomatch.every = function(list, patterns, options) {\r\n  if (typeof list === 'string') {\r\n    list = [list];\r\n  }\r\n\r\n  for (var i = 0; i < list.length; i++) {\r\n    if (nanomatch(list[i], patterns, options).length !== 1) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n/**\r\n * Returns true if **any** of the given glob `patterns`\r\n * match the specified `string`.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.any(string, patterns[, options]);\r\n *\r\n * console.log(nm.any('a.a', ['b.*', '*.a']));\r\n * //=> true\r\n * console.log(nm.any('a.a', 'b.*'));\r\n * //=> false\r\n * ```\r\n * @param  {String|Array} `str` The string to test.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if any patterns match `str`\r\n * @api public\r\n */\r\n\r\nnanomatch.any = function(str, patterns, options) {\r\n  if (typeof str !== 'string') {\r\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\r\n  }\r\n\r\n  if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {\r\n    return false;\r\n  }\r\n\r\n  if (typeof patterns === 'string') {\r\n    patterns = [patterns];\r\n  }\r\n\r\n  for (var i = 0; i < patterns.length; i++) {\r\n    if (nanomatch.isMatch(str, patterns[i], options)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Returns true if **all** of the given `patterns`\r\n * match the specified string.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.all(string, patterns[, options]);\r\n *\r\n * console.log(nm.all('foo.js', ['foo.js']));\r\n * // true\r\n *\r\n * console.log(nm.all('foo.js', ['*.js', '!foo.js']));\r\n * // false\r\n *\r\n * console.log(nm.all('foo.js', ['*.js', 'foo.js']));\r\n * // true\r\n *\r\n * console.log(nm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\r\n * // true\r\n * ```\r\n * @param  {String|Array} `str` The string to test.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if any patterns match `str`\r\n * @api public\r\n */\r\n\r\nnanomatch.all = function(str, patterns, options) {\r\n  if (typeof str !== 'string') {\r\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\r\n  }\r\n\r\n  if (typeof patterns === 'string') {\r\n    patterns = [patterns];\r\n  }\r\n\r\n  for (var i = 0; i < patterns.length; i++) {\r\n    if (!nanomatch.isMatch(str, patterns[i], options)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.not(list, patterns[, options]);\r\n *\r\n * console.log(nm.not(['a.a', 'b.b', 'c.c'], '*.a'));\r\n * //=> ['b.b', 'c.c']\r\n * ```\r\n * @param {Array} `list` Array of strings to match.\r\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\r\n * @api public\r\n */\r\n\r\nnanomatch.not = function(list, patterns, options) {\r\n  var opts = extend({}, options);\r\n  var ignore = opts.ignore;\r\n  delete opts.ignore;\r\n\r\n  list = utils.arrayify(list);\r\n\r\n  var matches = utils.diff(list, nanomatch(list, patterns, opts));\r\n  if (ignore) {\r\n    matches = utils.diff(matches, nanomatch(list, ignore));\r\n  }\r\n\r\n  return opts.nodupes !== false ? utils.unique(matches) : matches;\r\n};\r\n\r\n/**\r\n * Returns true if the given `string` contains the given pattern. Similar\r\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.contains(string, pattern[, options]);\r\n *\r\n * console.log(nm.contains('aa/bb/cc', '*b'));\r\n * //=> true\r\n * console.log(nm.contains('aa/bb/cc', '*d'));\r\n * //=> false\r\n * ```\r\n * @param {String} `str` The string to match.\r\n * @param {String|Array} `patterns` Glob pattern to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if the patter matches any part of `str`.\r\n * @api public\r\n */\r\n\r\nnanomatch.contains = function(str, patterns, options) {\r\n  if (typeof str !== 'string') {\r\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\r\n  }\r\n\r\n  if (typeof patterns === 'string') {\r\n    if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {\r\n      return false;\r\n    }\r\n\r\n    var equals = utils.equalsPattern(patterns, options);\r\n    if (equals(str)) {\r\n      return true;\r\n    }\r\n    var contains = utils.containsPattern(patterns, options);\r\n    if (contains(str)) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  var opts = extend({}, options, {contains: true});\r\n  return nanomatch.any(str, patterns, opts);\r\n};\r\n\r\n/**\r\n * Returns true if the given pattern and options should enable\r\n * the `matchBase` option.\r\n * @return {Boolean}\r\n * @api private\r\n */\r\n\r\nnanomatch.matchBase = function(pattern, options) {\r\n  if (pattern && pattern.indexOf('/') !== -1 || !options) return false;\r\n  return options.basename === true || options.matchBase === true;\r\n};\r\n\r\n/**\r\n * Filter the keys of the given object with the given `glob` pattern\r\n * and `options`. Does not attempt to match nested keys. If you need this feature,\r\n * use [glob-object][] instead.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.matchKeys(object, patterns[, options]);\r\n *\r\n * var obj = { aa: 'a', ab: 'b', ac: 'c' };\r\n * console.log(nm.matchKeys(obj, '*b'));\r\n * //=> { ab: 'b' }\r\n * ```\r\n * @param {Object} `object` The object with keys to filter.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Object} Returns an object with only keys that match the given patterns.\r\n * @api public\r\n */\r\n\r\nnanomatch.matchKeys = function(obj, patterns, options) {\r\n  if (!utils.isObject(obj)) {\r\n    throw new TypeError('expected the first argument to be an object');\r\n  }\r\n  var keys = nanomatch(Object.keys(obj), patterns, options);\r\n  return utils.pick(obj, keys);\r\n};\r\n\r\n/**\r\n * Returns a memoized matcher function from the given glob `pattern` and `options`.\r\n * The returned function takes a string to match as its only argument and returns\r\n * true if the string is a match.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.matcher(pattern[, options]);\r\n *\r\n * var isMatch = nm.matcher('*.!(*a)');\r\n * console.log(isMatch('a.a'));\r\n * //=> false\r\n * console.log(isMatch('a.b'));\r\n * //=> true\r\n * ```\r\n * @param {String} `pattern` Glob pattern\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\r\n * @return {Function} Returns a matcher function.\r\n * @api public\r\n */\r\n\r\nnanomatch.matcher = function matcher(pattern, options) {\r\n  if (utils.isEmptyString(pattern)) {\r\n    return function() {\r\n      return false;\r\n    };\r\n  }\r\n\r\n  if (Array.isArray(pattern)) {\r\n    return compose(pattern, options, matcher);\r\n  }\r\n\r\n  // if pattern is a regex\r\n  if (pattern instanceof RegExp) {\r\n    return test(pattern);\r\n  }\r\n\r\n  // if pattern is invalid\r\n  if (!utils.isString(pattern)) {\r\n    throw new TypeError('expected pattern to be an array, string or regex');\r\n  }\r\n\r\n  // if pattern is a non-glob string\r\n  if (!utils.hasSpecialChars(pattern)) {\r\n    if (options && options.nocase === true) {\r\n      pattern = pattern.toLowerCase();\r\n    }\r\n    return utils.matchPath(pattern, options);\r\n  }\r\n\r\n  // if pattern is a glob string\r\n  var re = nanomatch.makeRe(pattern, options);\r\n\r\n  // if `options.matchBase` or `options.basename` is defined\r\n  if (nanomatch.matchBase(pattern, options)) {\r\n    return utils.matchBasename(re, options);\r\n  }\r\n\r\n  function test(regex) {\r\n    var equals = utils.equalsPattern(options);\r\n    var unixify = utils.unixify(options);\r\n\r\n    return function(str) {\r\n      if (equals(str)) {\r\n        return true;\r\n      }\r\n\r\n      if (regex.test(unixify(str))) {\r\n        return true;\r\n      }\r\n      return false;\r\n    };\r\n  }\r\n\r\n  // create matcher function\r\n  var matcherFn = test(re);\r\n  // set result object from compiler on matcher function,\r\n  // as a non-enumerable property. useful for debugging\r\n  utils.define(matcherFn, 'result', re.result);\r\n  return matcherFn;\r\n};\r\n\r\n/**\r\n * Returns an array of matches captured by `pattern` in `string, or\r\n * `null` if the pattern did not match.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.capture(pattern, string[, options]);\r\n *\r\n * console.log(nm.capture('test/*.js', 'test/foo.js'));\r\n * //=> ['foo']\r\n * console.log(nm.capture('test/*.js', 'foo/bar.css'));\r\n * //=> null\r\n * ```\r\n * @param {String} `pattern` Glob pattern to use for matching.\r\n * @param {String} `string` String to match\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.\r\n * @api public\r\n */\r\n\r\nnanomatch.capture = function(pattern, str, options) {\r\n  var re = nanomatch.makeRe(pattern, extend({capture: true}, options));\r\n  var unixify = utils.unixify(options);\r\n\r\n  function match() {\r\n    return function(string) {\r\n      var match = re.exec(unixify(string));\r\n      if (!match) {\r\n        return null;\r\n      }\r\n\r\n      return match.slice(1);\r\n    };\r\n  }\r\n\r\n  var capture = memoize('capture', pattern, options, match);\r\n  return capture(str);\r\n};\r\n\r\n/**\r\n * Create a regular expression from the given glob `pattern`.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.makeRe(pattern[, options]);\r\n *\r\n * console.log(nm.makeRe('*.js'));\r\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\r\n * ```\r\n * @param {String} `pattern` A glob pattern to convert to regex.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\r\n * @return {RegExp} Returns a regex created from the given pattern.\r\n * @api public\r\n */\r\n\r\nnanomatch.makeRe = function(pattern, options) {\r\n  if (pattern instanceof RegExp) {\r\n    return pattern;\r\n  }\r\n\r\n  if (typeof pattern !== 'string') {\r\n    throw new TypeError('expected pattern to be a string');\r\n  }\r\n\r\n  if (pattern.length > MAX_LENGTH) {\r\n    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');\r\n  }\r\n\r\n  function makeRe() {\r\n    var opts = utils.extend({wrap: false}, options);\r\n    var result = nanomatch.create(pattern, opts);\r\n    var regex = toRegex(result.output, opts);\r\n    utils.define(regex, 'result', result);\r\n    return regex;\r\n  }\r\n\r\n  return memoize('makeRe', pattern, options, makeRe);\r\n};\r\n\r\n/**\r\n * Parses the given glob `pattern` and returns an object with the compiled `output`\r\n * and optional source `map`.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.create(pattern[, options]);\r\n *\r\n * console.log(nm.create('abc/*.js'));\r\n * // { options: { source: 'string', sourcemap: true },\r\n * //   state: {},\r\n * //   compilers:\r\n * //    { ... },\r\n * //   output: '(\\\\.[\\\\\\\\\\\\/])?abc\\\\/(?!\\\\.)(?=.)[^\\\\/]*?\\\\.js',\r\n * //   ast:\r\n * //    { type: 'root',\r\n * //      errors: [],\r\n * //      nodes:\r\n * //       [ ... ],\r\n * //      dot: false,\r\n * //      input: 'abc/*.js' },\r\n * //   parsingErrors: [],\r\n * //   map:\r\n * //    { version: 3,\r\n * //      sources: [ 'string' ],\r\n * //      names: [],\r\n * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',\r\n * //      sourcesContent: [ 'abc/*.js' ] },\r\n * //   position: { line: 1, column: 28 },\r\n * //   content: {},\r\n * //   files: {},\r\n * //   idx: 6 }\r\n * ```\r\n * @param {String} `pattern` Glob pattern to parse and compile.\r\n * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.\r\n * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.\r\n * @api public\r\n */\r\n\r\nnanomatch.create = function(pattern, options) {\r\n  if (typeof pattern !== 'string') {\r\n    throw new TypeError('expected a string');\r\n  }\r\n  function create() {\r\n    return nanomatch.compile(nanomatch.parse(pattern, options), options);\r\n  }\r\n  return memoize('create', pattern, options, create);\r\n};\r\n\r\n/**\r\n * Parse the given `str` with the given `options`.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.parse(pattern[, options]);\r\n *\r\n * var ast = nm.parse('a/{b,c}/d');\r\n * console.log(ast);\r\n * // { type: 'root',\r\n * //   errors: [],\r\n * //   input: 'a/{b,c}/d',\r\n * //   nodes:\r\n * //    [ { type: 'bos', val: '' },\r\n * //      { type: 'text', val: 'a/' },\r\n * //      { type: 'brace',\r\n * //        nodes:\r\n * //         [ { type: 'brace.open', val: '{' },\r\n * //           { type: 'text', val: 'b,c' },\r\n * //           { type: 'brace.close', val: '}' } ] },\r\n * //      { type: 'text', val: '/d' },\r\n * //      { type: 'eos', val: '' } ] }\r\n * ```\r\n * @param {String} `str`\r\n * @param {Object} `options`\r\n * @return {Object} Returns an AST\r\n * @api public\r\n */\r\n\r\nnanomatch.parse = function(pattern, options) {\r\n  if (typeof pattern !== 'string') {\r\n    throw new TypeError('expected a string');\r\n  }\r\n\r\n  function parse() {\r\n    var snapdragon = utils.instantiate(null, options);\r\n    parsers(snapdragon, options);\r\n\r\n    var ast = snapdragon.parse(pattern, options);\r\n    utils.define(ast, 'snapdragon', snapdragon);\r\n    ast.input = pattern;\r\n    return ast;\r\n  }\r\n\r\n  return memoize('parse', pattern, options, parse);\r\n};\r\n\r\n/**\r\n * Compile the given `ast` or string with the given `options`.\r\n *\r\n * ```js\r\n * var nm = require('nanomatch');\r\n * nm.compile(ast[, options]);\r\n *\r\n * var ast = nm.parse('a/{b,c}/d');\r\n * console.log(nm.compile(ast));\r\n * // { options: { source: 'string' },\r\n * //   state: {},\r\n * //   compilers:\r\n * //    { eos: [Function],\r\n * //      noop: [Function],\r\n * //      bos: [Function],\r\n * //      brace: [Function],\r\n * //      'brace.open': [Function],\r\n * //      text: [Function],\r\n * //      'brace.close': [Function] },\r\n * //   output: [ 'a/(b|c)/d' ],\r\n * //   ast:\r\n * //    { ... },\r\n * //   parsingErrors: [] }\r\n * ```\r\n * @param {Object|String} `ast`\r\n * @param {Object} `options`\r\n * @return {Object} Returns an object that has an `output` property with the compiled string.\r\n * @api public\r\n */\r\n\r\nnanomatch.compile = function(ast, options) {\r\n  if (typeof ast === 'string') {\r\n    ast = nanomatch.parse(ast, options);\r\n  }\r\n\r\n  function compile() {\r\n    var snapdragon = utils.instantiate(ast, options);\r\n    compilers(snapdragon, options);\r\n    return snapdragon.compile(ast, options);\r\n  }\r\n\r\n  return memoize('compile', ast.input, options, compile);\r\n};\r\n\r\n/**\r\n * Clear the regex cache.\r\n *\r\n * ```js\r\n * nm.clearCache();\r\n * ```\r\n * @api public\r\n */\r\n\r\nnanomatch.clearCache = function() {\r\n  nanomatch.cache.__data__ = {};\r\n};\r\n\r\n/**\r\n * Compose a matcher function with the given patterns.\r\n * This allows matcher functions to be compiled once and\r\n * called multiple times.\r\n */\r\n\r\nfunction compose(patterns, options, matcher) {\r\n  var matchers;\r\n\r\n  return memoize('compose', String(patterns), options, function() {\r\n    return function(file) {\r\n      // delay composition until it's invoked the first time,\r\n      // after that it won't be called again\r\n      if (!matchers) {\r\n        matchers = [];\r\n        for (var i = 0; i < patterns.length; i++) {\r\n          matchers.push(matcher(patterns[i], options));\r\n        }\r\n      }\r\n\r\n      var len = matchers.length;\r\n      while (len--) {\r\n        if (matchers[len](file) === true) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n  });\r\n}\r\n\r\n/**\r\n * Memoize a generated regex or function. A unique key is generated\r\n * from the `type` (usually method name), the `pattern`, and\r\n * user-defined options.\r\n */\r\n\r\nfunction memoize(type, pattern, options, fn) {\r\n  var key = utils.createKey(type + '=' + pattern, options);\r\n\r\n  if (options && options.cache === false) {\r\n    return fn(pattern, options);\r\n  }\r\n\r\n  if (cache.has(type, key)) {\r\n    return cache.get(type, key);\r\n  }\r\n\r\n  var val = fn(pattern, options);\r\n  cache.set(type, key, val);\r\n  return val;\r\n}\r\n\r\n/**\r\n * Expose compiler, parser and cache on `nanomatch`\r\n */\r\n\r\nnanomatch.compilers = compilers;\r\nnanomatch.parsers = parsers;\r\nnanomatch.cache = cache;\r\n\r\n/**\r\n * Expose `nanomatch`\r\n * @type {Function}\r\n */\r\n\r\nmodule.exports = nanomatch;\r\n"]},"metadata":{},"sourceType":"script"}